#!/usr/bin/env -S bash -e

script_dir=$(cd "$(dirname "${BASH_SOURCE:-$0}")" && pwd) && readonly script_dir
lib_dir="$script_dir/lib/new" && readonly lib_dir
command_name=$(basename "$0") && readonly command_name
current_dir=$(pwd) && readonly current_dir
dot_bin_dir=${DOTPATH:-~/.dot}/bin && readonly dot_bin_dir
args=()
mode=
src_fnm=default
dst_fnm=

usage() {
  cat <<EOF

Create new executable shell file.

  Usage:
      $command_name [option] <create_file_name>
    Options
      -h|--help : Show this usage
      -b|--bin : Create new command file in $dot_bin_dir

    ex)
      new bash command_name
      new make go
      new make sls
      new make tf

    Existing template is..
$(if has tree; then tree "$lib_dir"; else find "$lib_dir"; fi | sed -e 's,^,      ,g')

EOF
}

initialize() {
  while true; do
    [[ -z $1 ]] && break
    case "$1" in
      # -e) dummy= ;;
      #-f*|--file*) file=${1#*=} ;;
      #-f|--file) shift && file=$1 ;;
      -h | --help) usage && exit 0 ;;
      -b | --bin) to_bin=1 ;;
      *) add_args "$1" ;;
    esac
    shift
  done
  set_arg
  check
}
set_arg() {
  local len=${#args[@]}
  [[ $len -eq 0 ]] && return
  if [[ $len -eq 1 ]]; then
    mode=bash
    dst_fnm="${args[0]}"
    return
  fi

  # Below is over 2 args length case
  mode="${args[0]}"
  dst_fnm="${args[1]}"
  if [[ $mode == "make" ]]; then
    src_fnm="${args[1]}.Makefile"
    dst_fnm=Makefile
  fi
}
check() {
  if [[ -z $dst_fnm ]]; then
    usage
    error "Specify create command name."
  fi
  if ! is_mode_bash && [[ $to_bin -eq 1 ]]; then
    usage
    error "Not supported. Bin option only enable bash mode."
  fi
}
# is_dummy() { [[ -n $dummy ]]; }
has() { command -v "${1}" >&/dev/null; }
add_args() { args+=("$@"); }
ink() {
  local stdin=
  if [[ -p /dev/stdin ]]; then
    stdin="$(cat <&0)"
  fi
  if [[ $# -eq 0 && -z $stdin ]]; then
    return
  fi

  local open="\033["
  local close="${open}0m"
  export black="0;30m"
  export red="1;31m"
  export green="1;32m"
  export yellow="1;33m"
  export blue="1;34m"
  export purple="1;35m"
  export cyan="1;36m"
  export gray="0;37m"
  export white="$close"

  local text="$stdin$*"
  local color="$close"

  case $1 in
    black | red | green | yellow | blue | purple | cyan | gray | white)
      eval color="\$$1"
      text="$stdin${*:2}"
      ;;
  esac

  # shellcheck disable=SC2059
  printf "${open}${color}${text}${close}\n" 1>&2
}
_log() {
  # shellcheck disable=SC2145
  echo "$(date +"%Y-%m-%d %H:%M:%S") ${@:2}" | ink ""
}
log() { _log yellow "$*"; }
error() {
  _log red "$*"
  exit 1
}

cat_template_bash_defualt() {
  cat <<'EOL'
#!/usr/bin/env -S bash -e

main() {
  :
}
main "$@"
EOL
}

find_exist_path_first() {
  for arg in "$@"; do
    [[ -z $arg ]] && continue
    if [[ -e $arg ]]; then
      echo "$arg"
      break
    fi
  done
}

is_mode_bash() { [[ $mode == "bash" ]]; }

generate_dst_f() {
  local src_f rel_src_f
  src_f=$(find_exist_path_first "$lib_dir/$mode/$src_fnm" "$lib_dir/$mode/default")
  if [[ -z $src_f || ! -e $src_f ]]; then
    if is_mode_bash; then
      log "==> Generating bash default template.."
      cat_template_bash_defualt >"$dst_f"
      return
    fi
    error "No such mode source template exist. mode:$mode"
  fi
  rel_src_f=${src_f/$lib_dir\//}
  log "==> Generating template from $rel_src_f.."
  cp "$src_f" "$dst_f"
}

generate() {
  generate_dst_f
  if ! is_mode_bash; then
    return
  fi
  chmod 775 "$dst_f"
}

main() {
  initialize "$@"
  local out=$current_dir
  if [[ $to_bin -eq 1 ]]; then
    out=$dot_bin_dir
  fi
  local dst_f=$out/$dst_fnm
  if [[ -e $dst_f ]]; then
    error "$dst_f is already exist."
  fi
  generate
  log "==> New shell template file generated to $dst_f."
  log "==> Edit it?(Y/n)"
  read -r yes_i_edit
  if [[ $yes_i_edit =~ [nN] ]]; then
    return
  fi
  local _vim=vim
  has nvim && _vim=nvim
  "$_vim" "$dst_f"
}
main "$@"
