#!/usr/bin/env -S bash -e

script_dir=$(cd "$(dirname "${BASH_SOURCE:-$0}")" && pwd) && readonly script_dir
lib_dir="$script_dir/lib/new" && readonly lib_dir
command_name=$(basename "$0") && readonly command_name
current_dir=$(pwd) && readonly current_dir
dot_bin_dir=${DOTPATH:-~/.dot}/bin && readonly dot_bin_dir
args=()
mode=
src_fnm=default
dst_fnm=
dst_files=()

usage() {
  cat <<EOF

Create new executable shell file.

  Usage:
      $command_name [option] <create_file_name>
    Options
      -h|--help : Show this usage
      -b|--bin : Create new command file in $dot_bin_dir
      -q|--quiet : Quiet mode

    ex)
      new bash command_name
      new make go
      new make sls
      new make tf
      new make docker-compose

    Existing template is..
$(if has tree; then tree "$lib_dir"; else find "$lib_dir"; fi | sed -e 's,^,      ,g')

EOF
}

initialize() {
  set -eo pipefail
  while true; do
    [[ -z $1 ]] && break
    case "$1" in
      # -e) dummy= ;;
      #-f*|--file*) file=${1#*=} ;;
      #-f|--file) shift && file=$1 ;;
      -h | --help) usage && exit 0 ;;
      -b | --bin) to_bin=1 ;;
      -q | --quiet) quiet=1 ;;
      *) add_args "$1" ;;
    esac
    shift
  done
  set_arg
  check
}
set_arg() {
  local len=${#args[@]}
  [[ $len -eq 0 ]] && return
  if [[ $len -eq 1 ]]; then
    mode=bash
    dst_fnm="${args[0]}"
    return
  fi

  # Below is over 2 args length case
  mode="${args[0]}"
  if [[ $mode != "make" ]]; then
    usage
    error "Not supported mode $mode"
  fi
  src_fnm="${args[1]}"
}
check() {
  if is_mode_bash; then
    if [[ -z $dst_fnm ]]; then
      usage
      error "Specify create command name."
    fi
    return
  fi

  if [[ $to_bin -eq 1 ]]; then
    usage
    error "Not supported. Bin option enable only bash mode."
  fi
}
# is_dummy() { [[ -n $dummy ]]; }
has() { command -v "${1}" >&/dev/null; }
add_args() { args+=("$@"); }
add_dst_files() { dst_files+=("$@"); }
ink() {
  local stdin=
  if [[ -p /dev/stdin ]]; then
    stdin="$(cat <&0)"
  fi
  if [[ $# -eq 0 && -z $stdin ]]; then
    return
  fi

  local open="\033["
  local close="${open}0m"
  export black="0;30m"
  export red="1;31m"
  export green="1;32m"
  export yellow="1;33m"
  export blue="1;34m"
  export purple="1;35m"
  export cyan="1;36m"
  export gray="0;37m"
  export white="$close"

  local text="$stdin$*"
  local color="$close"

  case $1 in
    black | red | green | yellow | blue | purple | cyan | gray | white)
      eval color="\$$1"
      text="$stdin${*:2}"
      ;;
  esac

  # shellcheck disable=SC2059
  printf "${open}${color}${text}${close}\n" 1>&2
}
_log() {
  # shellcheck disable=SC2145
  echo "$(date +"%Y-%m-%d %H:%M:%S") ${@:2}" | ink ""
}
log() { _log yellow "$*"; }
error() {
  _log red "$*"
  exit 1
}

cat_template_bash_defualt() {
  cat <<'EOL'
#!/usr/bin/env -S bash -e

main() {
  :
}
main "$@"
EOL
}

find_exist_path_first() {
  for arg in "$@"; do
    [[ -z $arg ]] && continue
    if [[ -e $arg ]]; then
      echo "$arg"
      break
    fi
  done
}

is_mode_bash() { [[ $mode == "bash" ]]; }

generate_dst_files() {
  local src_f_or_d src_files rel_src_f dst_f
  src_f_or_d=$(find_exist_path_first "$lib_dir/$mode/$src_fnm" "$lib_dir/$mode/default")
  if [[ -z $src_f_or_d || ! -e $src_f_or_d ]]; then
    if ! is_mode_bash; then
      error "No such mode source template exist. mode:$mode"
    fi
    src_f_or_d=$(mktemp)
    cat_template_bash_defualt >"$src_f_or_d"
  fi
  src_files=$(fire_src_files)
  for src_f in $src_files; do
    dst_f=$out/$dst_fnm
    if ! is_mode_bash; then
      dst_f=$out/$(basename "$src_f")
    fi
    add_dst_files_with_check "$dst_f"
    rel_src_f=${src_f/$lib_dir\//}
    log "==> Generating template from $rel_src_f.."
    cp "$src_f" "$dst_f"
  done
}

add_dst_files_with_check() {
  local _dst_f="$*"
  if [[ -e $_dst_f ]]; then
    error "$_dst_f is already exist."
  fi
  add_dst_files "$_dst_f"
}

fire_src_files() {
  if [[ -d $src_f_or_d ]]; then
    find "$src_f_or_d"/ -type f
    return
  fi
  echo "$src_f_or_d"
}

generate() {
  generate_dst_files
  if ! is_mode_bash; then
    return
  fi
  for f in "${dst_files[@]}"; do
    chmod 775 "$f"
  done
}

main() {
  initialize "$@"
  local out=$current_dir
  if [[ $to_bin -eq 1 ]]; then
    out=$dot_bin_dir
  fi
  generate
  [[ $quiet -eq 1 ]] && return
  log "==> New template file generated."
  log "==> Edit it?(Y/n)"
  read -r yes_i_edit
  if [[ $yes_i_edit =~ [nN] ]]; then
    return
  fi
  local _vim=vim
  has nvim && _vim=nvim
  "$_vim" -p "${dst_files[@]}"
}
main "$@"
