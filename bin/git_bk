#!/usr/bin/env bash

readonly timestamp=$(date +%Y%m%d%H%M%S)
dummy="echo"
restore=0

initialize() {
  for arg in "$@"; do
    case "$arg" in
    -e) dummy= ;;
    -r) restore=1 ;;
    esac
  done
}
check() {
  local result=$(git rev-parse --is-inside-work-tree 2>/dev/null)
  if [[ $result == true ]]; then
    return
  fi
  echo "Not in git repository" 1>&2
  exit 1
}
get_prj_name() {
  basename $(get_git_root)
}
bkup_files() {
  local hash=$(git rev-parse --short HEAD)
  # local tmpd=$(mktemp -d)
  local tmpd=/tmp/${timestamp}_${prj_name}_${hash}
  local status=$tmpd/status
  local mod_files_d=$tmpd/mod_files
  $dummy mkdir -p $mod_files_d
  git status -s 2>&1 | tee $status
  git status -s |
    grep -E -v '^ D ' |
    cut -c4- |
    while read -r rel_path; do
      [[ -z $rel_path ]] && continue
      [[ $rel_path =~ ^#.* ]] && continue
      $dummy cp --parents $rel_path $mod_files_d/
    done
  echo "Done! snapshot saved to $tmpd"
}
restore_files() {
  local srcd=$(find /tmp -maxdepth 1 -mindepth 1 -type d -name "*$prj_name*" |
    fzf)
  if [[ -z $srcd ]]; then
    echo "specify srcd" 1>&2
    exit 1
  fi
  set -e
  cd $srcd/mod_files
  find . -type f |
    while read -r rel_path; do
      [[ -z $rel_path ]] && continue
      [[ $rel_path =~ ^#.* ]] && continue
      $dummy cp -vf --parents $rel_path $git_root/
    done
}
main() {
  initialize "$@"
  check

  local git_root=$(get_git_root)
  cd $git_root
  local prj_name=$(get_prj_name)

  if [[ $restore -eq 1 ]]; then
    restore_files
  else
    bkup_files
  fi
  [[ -z $dummy ]] && return
  echo
  echo "> This is dummy mode. specify -e option"
  echo
}
main "$@"
