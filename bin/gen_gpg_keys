#!/usr/bin/env bash

# @see https://qiita.com/moutend/items/5c22d6e57a74845578f6
command_name=$(basename "$0") && readonly command_name
readonly conf_path=$0.conf

usage() {
  cat <<EOF

Generate gpg keys via gen config

Usage:
  $command_name [option]
Options
  -h : Show this usage
  -g <passphrase> : Gen config

EOF
}

has() { command -v "${1}" >&/dev/null; }
_ink() { cat - | if has ink; then ink "$@"; else cat -; fi; }
# shellcheck disable=SC2145
_log() { echo "$(date +"%Y-%m-%d %H:%M:%S") ${@:2}" | _ink "$1"; }
log() { _log cyan "$*"; }
error() { _log red "$*" && exit 1; }
cat_conf() {
  cat <<EOF
# Unattended GPG key generation - Using the GNU Privacy Guard
# https://www.gnupg.org/documentation/manuals/gnupg/Unattended-GPG-key-generation.html
Key-Type: RSA
Key-Length: 4096
Subkey-Type: RSA
Subkey-Length: 4096
# 2 years
Expire-Date: 2y

Name-Real: $name
Name-Email: $email
Passphrase: $pass

# create kyes abouve settings
%commit
%echo Successfully done
EOF
}

get_git_global_value() {
  git config --global --get "$1"
}

setup_from_git_config() {
  name=$(get_git_global_value user.name)
  email=$(get_git_global_value user.email)
  if [[ -z $name || -z $email ]]; then
    echo "Setup git config global. user.name,user.email." 1>&2
    exit 1
  fi
}

setup_conf() {
  if [[ -e $conf_path ]]; then
    echo "Already setupped $conf_path"
    return
  fi
  if [[ -z $pass ]]; then
    echo "Specify passphrase." 1>&2
    exit 1
  fi
  cat_conf >"$conf_path"
  log "==> gpg config generated. Re-Run"
}

gen() {
  if gpg -k | grep "$name" >&/dev/null; then
    log "==> Already gpg key $name exist."
    gpg -k
  else
    log "==> Generating gpg key via $conf_path.."
    gpg --gen-key --batch "$conf_path"
  fi
  gpg -o ./"$name.public.gpg" --export "$name"
  gpg -o ./"$name.private.gpg" --export-secret-key "$name"
  cat <./"$name.public.gpg" | base64 | tr -d '\n' >./"$name.public.gpg.base64"
}

main() {
  [[ $1 == -h ]] && usage && exit
  setup_from_git_config
  if [[ $1 == -g ]]; then
    log "==> Generating gpg config.. $conf_path"
    pass=$2
    setup_conf
    return
  fi
  if [[ ! -e $conf_path ]]; then
    usage
    error "No $conf_path. Execute with -g option."
  fi
  gen
}
main "$@"
