#!/usr/bin/env bash

readonly depends=(curl fzf jq)
command_name=$(basename "$0") && readonly command_name
worktree_dir_name="___git_worktree" && readonly worktree_dir_name
args=()
mode=list

usage() {
  cat <<EOF

Manage repository tasks.

  Usage:
      $command_name [option]
    Options
      -h|--help       : Show this usage
      -s|--split      : Split tasks into multiple files
      -sa|--split-all : Split all tasks into multiple files
      -n|--next       : Show next task chunk
      -c|--clean      : Move completed tasks to .tasks/done/done.md

EOF
}

initialize() {
  while true; do
    [[ -z $1 ]] && break
    case "$1" in
      -h | --help) usage && exit 0 ;;
      -s | --split) mode="split" ;;
      -sa | --split-all) mode="split-all" ;;
      -n | --next) mode="next" ;;
      -c | --clean) mode="clean" ;;
      # -f*|--file*) file=${1#*=} ;;
      # -f|--file) shift && file=$1 ;;
      *) add_args "$1" ;;
    esac
    shift
  done
  check
  set -euo pipefail
}
check() { hass "${depends[@]}"; }
add_args() { args+=("$@"); }
has() { command -v "${1}" >&/dev/null; }
hass() { for arg in "$@"; do has "$arg" || error "==> No $arg command exist."; done; }
_ink() { cat - | if has ink; then ink "$@"; else cat -; fi; }
# shellcheck disable=SC2145
_log() { echo "$(date +"%Y-%m-%d %H:%M:%S") ${@:2}" | _ink "$1"; }
log() { _log white "$*"; }
info() { _log cyan "$*"; }
warn() { _log yellow "$*"; }
error() { _log red "$*" && exit 1; }
current_is_worktree_dir() { [[ $git_root =~ ^.*/${worktree_dir_name}/.*$ ]]; }

initialize_links_if_needed() {
  [[ -e $target_file ]] && return

  if current_is_worktree_dir; then
    init_link_tasks_for_worktree
    return
  fi

  # Initialize if Not exist and Not in worktree directory
  init_link_tasks
}

init_link_tasks() {
  info "==> Initialize tasks for repository root directory.."
  repo_name=$(basename "$git_root")
  srcd="$HOME/.mo/tasks/$repo_name"
  info "==> Creating tasks directory at $srcd"
  mkdir -p "$srcd"/tasks/done
  touch "$srcd"/tasks.md
  info "==> Linking .tasks/ directory to $git_root"
  ln -s "$srcd/tasks" "$git_root/.tasks"
  info "==> Linking .tasks.md to $git_root"
  ln -s "$srcd/tasks.md" "$git_root/.tasks.md"
}

init_link_tasks_for_worktree() {
  info "==> Initialize tasks for worktree directory.."
  worktree_name=$(basename "$git_root")
  repo_name=$(basename "${git_root%%/.git/*}")
  srcd="$HOME/.mo/tasks/$repo_name"
  info "==> Creating tasks directory at $srcd"
  mkdir -p "$srcd"/tasks/done
  touch "$srcd"/tasks.md
  mkdir -p "$srcd"/tasks/"$worktree_name"
  touch "$srcd"/tasks/"$worktree_name"/tasks.md
  info "==> Linking .tasks.md to $git_root"
  ln -s "$srcd"/tasks/"$worktree_name"/tasks.md "$git_root/.tasks.md"
}

find_tasks() {
  echo .tasks.md
  rg --files .tasks/ | sort
}

cat_first_task() {
  # awk '
  #   /^- / {
  #     if (in_task) {
  #       exit
  #     }
  #   }
  #   /^- \[ \]/ {
  #     in_task = 1
  #     print
  #     next
  #   }
  #   {
  #     if (in_task) {
  #       print
  #     }
  #   }
  # ' "$target_file"
  # parse_first_task
  parse_tasks 0
  sed -n "${first_line},${end_line}p" "$target_file"
}

# parse_first_task() {
#   if [[ ! -s $target_file ]] || ! grep -qE '^- \[ \]' "$target_file"; then
#     error "==> Empty tasks. $target_file"
#   fi

#   # チェックボックス行の行番号を取得
#   line_numbers=$(grep -nE '^- \[ \]' "$target_file" | cut -d: -f1)

#   # 最初の行番号を取得
#   first_line=$(echo "$line_numbers" | head -n1)

#   # 2番目の行番号を取得（なければファイル末尾）
#   second_line=$(echo "$line_numbers" | sed -n '2p')
#   if [[ -z $second_line ]]; then
#     second_line=$(($(wc -l <"$target_file") + 1))
#   fi

#   # 範囲を計算（2番目の直前まで）
#   end_line=$((second_line - 1))
# }

parse_tasks() {
  comp=$1
  grep_key='- \[ \]'
  [[ $comp -eq 1 ]] && grep_key='- \[[xX]\]'
  if [[ ! -s $target_file ]] || ! grep -qE "^$grep_key" "$target_file"; then
    error "==> Empty tasks. $target_file"
  fi

  read -r first_line second_line <<<"$(
    grep -nE '^- ' "$target_file" |
      grep -A1 -E "[0-9]+:$grep_key" |
      head -2 |
      cut -d: -f1 |
      tr '\n' ' '
  )"

  # 2番目の行番号がなければファイル末尾
  if [[ -z $second_line ]]; then
    second_line=$(($(wc -l <"$target_file") + 1))
  fi

  # 範囲を計算（2番目の直前まで）
  end_line=$((second_line - 1))
}

split_tasks() {
  # tempファイルに抽出
  local temp_file
  temp_file=$(mktemp)
  cat_first_task >"$temp_file"

  # 元ファイルから削除
  sed -i "${first_line},${end_line}d" "$target_file"

  # prpコマンドでJSON取得
  local json_result
  json_result=$(cat "$temp_file" | prp -ne gen-task-title-and-branch.md$ | llm -c tgpt -p groq)

  # JSON解析
  local branch name title
  branch=$(echo "$json_result" | jq -r '.branch')
  name=$(echo "$json_result" | jq -r '.name')
  title=$(echo "$json_result" | jq -r '.title')

  # タスクファイル作成
  local timestamp
  timestamp=$(date +"%Y-%m-%d_%H-%M-%S")
  local task_file=".tasks/${timestamp}_${name}.md"
  # NOTE: git_worktree -a で link まで貼られるので、事前にファイル作成しておく
  touch "$task_file"

  # worktree ブランチ作成
  local worktree_dir
  worktree_dir=$(git_worktree -a "${branch}")

  # マークダウン形式でファイル作成
  cat >"$task_file" <<EOF
## ${title}
### ブランチ名
- ${branch}
### 作業ディレクトリ
- ${worktree_dir}
### タスク内容
$(cat "$temp_file")
EOF

  # link task_file
  ln -s "$git_root/$task_file" "$worktree_dir/.tasks.md"
  if [[ ! -e "$worktree_dir/.tasks" ]]; then
    ln -s "$git_root/.tasks" "$worktree_dir/.tasks"
  fi

  # tempファイル削除
  rm -f "$temp_file"

  info "==> Task split to: $task_file"
  info "==> Branch: $branch"
}

split_tasks_all() {
  split_tasks
  # まだタスクが残っていれば再帰的に処理
  if grep -qE '^- \[ \]' "$target_file"; then
    split_tasks_all
  fi
}

clean_tasks() {
  local done_file="$git_root/.tasks/done/done.md"
  parse_tasks 1
  sed -n "${first_line},${end_line}p" "$target_file" | tee -a "$done_file"
  # 元ファイルから削除
  sed -i "${first_line},${end_line}d" "$target_file"

  # まだタスクが残っていれば再帰的に処理
  if grep -qE '^- \[[xX]\]' "$target_file"; then
    clean_tasks
    return
  fi
  info "==> Task cleaned"
}

main() {
  initialize "$@"
  git_root=$(git rev-parse --show-toplevel)
  cd "$git_root" || exit 1
  target_file="$git_root/.tasks.md"
  initialize_links_if_needed

  if [[ $mode == "next" ]]; then
    cat_first_task
    return
  fi
  if [[ $mode == "split" ]]; then
    split_tasks
    return
  fi
  if [[ $mode == "split-all" ]]; then
    split_tasks_all
    return
  fi
  if [[ $mode == "clean" ]]; then
    clean_tasks
    return
  fi
  find_tasks | v
}
main "$@"
