#!/usr/bin/env bash

readonly command_name=$(basename $0)
readonly script_dir=$(
  cd "$(dirname $0)"
  pwd
)
readonly apps_dir=$(
  cd "$script_dir/../apps"
  pwd
)
# 関数ロード
source $script_dir/lib/setup/funcs
export PATH=$script_dir:$PATH
export DETECT_OS=$(os)
export DOT_PATH=$HOME/.dot

default_apps_min=(git ssh tig curl bc tree tmux zsh vim ag ctags)
default_apps=("${default_apps_min[@]}" fzf neofetch anyenv go pt rg nkf mmv gomi ghq shellcheck shfmt htop hub)

# Dynamic Variables
export debug=0
export dry_run=1
export force=0
export view=0
args=()

usage() {
  cat <<EOF
Setup my dev env.
  Usage:
      $command_name [Option] [App App...]
    Options
      -h|--help
        Show this usage
      -d|--debug
        whith debug option
      -e|--exec
        execute install/setup process.
      -f|--force
        install process will be executed forcibly if already installed, and also setup process will be executed.
      -v|--view
        vim edit apps config

Installable Apps is ..
$(installable_apps | usage_format)
Default Apps is..
$(for arg in "${default_apps[@]}"; do echo $arg; done | usage_format)
Trans Setup is..
$(find_trans -l | usage_format)
EOF
}

installable_apps() {
  find $apps_dir/ -maxdepth 1 -mindepth 1 -type d -exec basename {} \;
}

usage_format() {
  local _start=1
  local _line=
  cat - |
    while read -r _app_name; do
      local _space=" "
      [[ $_start -eq 1 ]] && _space="  " && _start=0
      printf "$_space$_app_name"
      _line="$_line$_space$_app_name"
      _n=$(echo -n "$_line" | wc -c)
      [[ $_n -lt 100 ]] && continue
      printf '\n' && _line= && _start=1
    done
}

add_args() { args+=("$@"); }

initialize() {
  while true; do
    [[ -z $1 ]] && break
    case "$1" in
    -h | --help) usage && exit 0 ;;
    #-f*|--file*) file=${1#*=} ;;
    #-f|--file) shift && file=$1 ;;
    -e | --exec) dry_run=0 ;;
    -v | --view) view=1 ;;
    -f | --force) force=1 ;;
    -d | --debug) debug=1 ;;
    *) add_args $1 ;;
    esac
    shift
  done

  tran_srouce=$(find_trans "${args[@]}")
  if [[ -n $tran_srouce ]]; then
    ilog "=> tran settings"
    source $tran_srouce
    load_update_arg_apps
  fi

  if [[ ${#args[@]} -eq 0 ]]; then
    args+=("${default_apps[@]}")
  fi

  all_args="${args[*]}"

  handle_view_if_needed

  if is_mac; then
    if ! has brew && ! echo "$all_args" | grep brew >&/dev/null; then
      args=(brew "${args[@]}")
    fi
  fi
}

handle_view_if_needed() {
  if [[ $view -ne 1 ]]; then
    return
  fi
  local filter_keys=
  if [[ ${#args[@]} -ne 0 ]]; then
    filter_keys="($(echo -n "${args[@]}" | tr ' ' '|'))"
  fi

  installable_apps |
    if [[ -z $filter_keys ]]; then
      cat -
    else
      cat - | grep -E "$filter_keys"
    fi | xargs -n 1 -I{} echo $apps_dir/{}/config | v
  exit 0
}

make_setup_dirs() {
  local works_home=$HOME
  if is_msys; then
    if [ -z $WINHOME ]; then
      WINHOME="$(cd "/c/Users/$(whoami)" && pwd)"
    fi
    works_home=$WINHOME
  fi
  make_dir_if_needed "$works_home/bin"
  make_dir_if_needed "$works_home/tools"
  make_dir_if_needed "$works_home/works/00_memos"
  if ! is_msys; then
    return
  fi
  make_lnk_with_bkup $WINHOME $HOME/win
  make_lnk_with_bkup $WINHOME/bin $HOME/bin
  make_lnk_with_bkup $WINHOME/tools $HOME/tools
  make_lnk_with_bkup $WINHOME/works $HOME/works
  make_lnk_with_bkup $WINHOME/Downloads $HOME/Downloads
}

# suggest_install_brew() {
#   cat <<'EOF'
# ================================================
#  HomeBrew is Not Installed!
#   => You need to install brew first.
#     echo "export PATH=/usr/local/bin:\$PATH" >> ~/.bash_profile
#     sudo mkdir /usr/local/
#     /usr/bin/ruby -e "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)"
#     source ~/.bash_profile
#     brew update
#     brew -v
#
# EOF
# }
#
debug_options() {
  dlog "===================================================="
  dlog " Execute with below args."
  dlog "   ===> Apps: $all_args"
  dlog "   ===> force: $force"
  dlog "   ===> dry_run: $dry_run"
  dlog "   ===> view: $view"
  dlog "===================================================="
}

show_dummy_warn_if_needed() {
  if ! is_dry; then
    return
  fi
  ilog "===================================================="
  ilog " This is Dry-run mode. :D"
  ilog "===================================================="
}

install_app() {
  default_called=0
  is_arch && install_arch
  is_msys && install_msys
  is_cygwin && install_cygwin
  is_mac && install_mac
  is_ubuntu && install_ubuntu
  is_redhat && install_redhat
  if [[ $default_called -eq 1 ]]; then
    install_common
  fi
}

setting_app() {
  default_called=0
  is_arch && setting_arch
  is_msys && setting_msys
  is_cygwin && setting_cygwin
  is_mac && setting_mac
  is_ubuntu && setting_ubuntu
  is_redhat && setting_redhat
  if [[ $default_called -eq 1 ]]; then
    setting_common
  fi
}

not_supported() {
  local _message="==> No setting exist."
  if [[ $for_setting -ne 1 ]]; then
    _message="==> Not supported."
    not_supported=1
  fi
  log "$_message"
}

setup_for_app() {
  dlog "================================================"
  ilog "=> For $app"

  not_supported=0
  if [[ $force -eq 1 ]] || ! is_installed; then
    for_setting=0
    install_app
  fi
  if [[ $not_supported -ne 1 ]]; then
    if is_dry || is_installed; then
      for_setting=1
      setting_app
    fi
  fi
}

main_setup() {
  make_setup_dirs

  for ((i = 0; i < ${#args[@]}; i++)); do
    # ディレクトリ名＝アプリ名の前提
    local app=${args[i]}

    app_dir=$apps_dir/$app
    if [[ ! -e $app_dir ]]; then
      log "=> No such app $app"
      continue
    fi
    source $script_dir/lib/setup/default
    local script_path=$app_dir/config
    if [[ -e $script_path ]]; then
      source $script_path
    fi
    setup_for_app
  done
}

start_setup() {
  set -e
  cd $DOT_PATH
  ilog "> Prev"
  pre_setup
  ilog "> Main"
  main_setup
  ilog "> Post"
  post_setup
}

main() {
  initialize "$@"
  debug_options
  start_setup
  show_dummy_warn_if_needed
  ink green "Done!"
  echo
}
main "$@"
