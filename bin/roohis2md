#!/usr/bin/env bash

command_name=$(basename "$0") && readonly command_name
src_root_dir="$HOME"/.config/Cursor/User/globalStorage/rooveterinaryinc.roo-cline/tasks
dst_root_dir="$HOME"/.mo/knowledge

readonly depends=(jq prp llm)
has() { command -v "${1}" >&/dev/null; }
hass() { for arg in "$@"; do has "$arg" || error "==> No $arg command exist."; done; }
_ink() { cat - | if has ink; then ink "$@"; else cat -; fi; }
# shellcheck disable=SC2145
_log() { echo "$(date +"%Y-%m-%d %H:%M:%S"): $command_name: ${@:2}" | _ink "$1"; }
log() { _log white "$*"; }
info() { _log cyan "$*"; }
warn() { _log yellow "$*"; }
error() { _log red "$*" && exit 1; }

# Markdownヘッダーを出力
cat_content_header() {
  title="$1"
  # 現在時刻を取得してフォーマット
  formatted_time=$(date '+%Y-%m-%d %H:%M:%S')

  cat <<EOF
<!-- Generated by roohis2md -->

# ${title} (${formatted_time})

EOF
}

convert_to_markdown() {
  info "===> Converting $file_path to Markdown..."
  cat <"$file_path" |
    jq -r '.[] | select(.say != "api_req_started" and .say != "checkpoint_saved" and .ask != "tool" and .ask != "api_req_failed" and .say != "command_output") | "TS:\(.ts)|\(.text // "")"' |
    # Remove empty lines
    grep -v '^TS:[0-9]\{13\}|$' |
    # Convert Unix timestamp ms to human-readable format
    awk '
      /^TS:[0-9]{13}\|/ {
        ts = substr($0, 4, 13)
        text = substr($0, 18)
        cmd = "date -d @" int(ts/1000) " \"+%Y-%m-%d %H:%M:%S\""
        cmd | getline formatted
        close(cmd)
        print "\n" "## " formatted "\n"
        if (length(text) > 0) print text
        print ""
        next
      }
      { print }
    '
}

format_timestamp() {
  awk '{print int($1/1000)}' |
    xargs -I {} date -d "@{}" "+%Y-%m-%d_%H-%M"
}

get_contents_title() {
  info "===> Generating title from contents via llm..."
  prp -ne gen-knowledge-filename-ja.md |
    llm
}

main() {
  hass "${depends[@]}"
  find "$src_root_dir"/*/ui_messages.json |
    while read -r file_path; do
      ts=$(cat <"$file_path" | jq -r '.[-1].ts')
      echo "$ts $file_path"
    done |
    sort -r |
    # head -1 |
    # find ./samples/ui_messages.json |
    while read -r ts file_path; do
      [[ -z $ts ]] && continue
      [[ $ts =~ ^#.* ]] && continue
      prefix=$(echo "$ts" | format_timestamp)
      yyyy=$(echo "$prefix" | cut -d'-' -f1)
      # echo "===> prefix:$prefix" && continue
      # Exit if the file already exists
      find "$dst_root_dir/$yyyy/$prefix"*md -type f 2>/dev/null | grep -q . && {
        info "===> Aready Deployed file exist. Quiting.."
        break
      }
      tmp=/tmp/$prefix-tmp.md
      convert_to_markdown >"$tmp"
      title=$(cat <"$tmp" | get_contents_title)
      dst="$dst_root_dir/$yyyy/$prefix-$title.md"
      info "===> Deploying to $dst.."
      mv -f "$tmp" "$dst"
    done
  info "==> Done"
}

main "$@"
