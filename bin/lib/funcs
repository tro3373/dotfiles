#!/bin/bash

DOT_PATH=~/.dot
DETECT_OS=$($DOT_PATH/bin/os)
DETECT_BIT=$($DOT_PATH/bin/bit)
_timestamp=$(date +%Y%m%d.%H%M%S)
_backup_root="${DOT_PATH}/bkup/setup"
# _log_file="${DOT_PATH}"/bkup/$_timestamp.setup.log
_dry_run_commands=""

is_debug() { [[ $debug -eq 1 ]]; }
is_dry() { [[ $dry_run -eq 1 ]]; }
log() {
    echo -e "$*"
}

dlog() {
    if is_debug; then
        log "$*"
    fi
}

mexe() {
    local cmd="$*"
    is_dry && log "   $cmd" && return
    dlog "===> Executing: $cmd"
    if eval "$cmd"; then
        dlog "    => Command Sucessfully."
    else
        dlog "    => Command Failed......"
    fi
}

# コマンドがインストールされているかチェックする
has() { which $1 >& /dev/null; }

# $* が存在するかどうか判定する
isexist() {
    local file="$*"
    local count=$(ls -a "$file" 2>/dev/null |wc -l|sed 's/ //g')
    [[ $count -eq 0 ]] && return 1
    return 0
}

make_dir_if_needed() {
    local tmp="$*"
    if [[ ! -e "$tmp" ]]; then
        mexe "mkdir -p \"$tmp\""
    fi
}

# $1のファイルを$2へリンクを作成する
make_link() {
    local from=$1
    local to=$2
    mexe "ln -s \"$from\" \"$to\""
}

# $* のリンクを 絶対パスで表示する（readlink -f の代用（For Mac））
# echo 結果がパスとして使用される為、log 実行時は正しく動作しない
readlink_path() {
    local target="$*"
    if [ "$target" = "" ]; then
        echo "Error!!! readlink_path Error!!!!!!!! argument is blank!!"
        return
    fi
    buf="`echo $target`"
    pre=""
    while [ "$buf" != "" ]; do
        pre="`echo $buf`"
        buf="`readlink "$buf"`"
    done
    echo "$pre"
}

# $* ディレクトリ配下の dot file をHOMEへリンクを作成する
make_link_dot2home() {
    local dir="$*"
    for file in `cd "$dir" && /bin/ls -a | grep -v ^.git$ | grep -v ^.gitignore$ | grep -v ^.gitkeep$ | egrep '^\.[^.]+'`; do
        make_lnk_with_bkup "$dir/$file" "${HOME}/$file"
    done
}

# 同じリンクかどうか
is_same_link() {
    local src1=$1
    local src2=$2
    if [ "$src1" = "$src2" ]; then
        return 1
    fi
    if [ "$src1/" = "$src2" ]; then
        return 1
    fi
    if [ "$src1" = "$src2/" ]; then
        return 1
    fi
    return 0
}

# $1のファイルを$2へリンクを作成する
make_lnk_with_bkup() {
    local src=$1
    local lnk=$2
    local need_backup=0
    # dlog " make_lnk_with_bkup Start lnk=$lnk src=$src"
    #if [ -e "${lnk}" ]; then
    if isexist "${lnk}"; then
        # dlog "   @@@@@@ exist!"
        # ファイルタイプ(ファイル、ディレクトリ、リンク)をチェック
        #if [ -n "`find "${lnk}" -maxdepth 0 -type l`" ]; then
        if [ -L "${lnk}" ]; then
            # リンク
            # dlog "   @@@@@@ Link!"
            local fullpath_lnk="`readlink_path "${lnk}"`"
            local fullpath_src="`readlink_path "${src}"`"
            # dlog "    lnk:$lnk => fullpath_lnk=$fullpath_lnk"
            # dlog "    src:$src => fullpath_src=$fullpath_src"
            if ! is_same_link "$fullpath_lnk" "$fullpath_src"; then
                # 既に自分へのリンクの場合はなにもしない
                # dlog "  => Already linked. Skip it. path=${lnk}"
                return 0
            else
                # 他ファイルへのリンクなのでバックアップする
                # dlog "  => Not match link. backup it. old link is ${fullpath_lnk} => new link is ${fullpath_src}"
                need_backup=1
            fi
        elif [ -d "${lnk}" ]; then
            # ディレクトリはバックアップする
            # dlog "   @@@@@@ Dir!"
            dlog "  => Directory exist. Backup it. path=$lnk"
            need_backup=1
        elif [ -f "${lnk}" ]; then
            # 既存のファイルをバックアップする
            # dlog "   @@@@@@ File!"
            dlog "  => File exist. Backup it. path=$lnk"
            need_backup=1
        else
            # dlog "   @@@@@@ little bit!"
            # ないと思う
            dlog "  => Little bit strange exist. path=${lnk} ... Do nothing"
            return 0
        fi
    fi
    # バックアップが必要ならバックアップする
    if [ $need_backup -eq 1 ]; then
        # dlog "   @@@@@@ Backup!"
        backup_file "${lnk}"
    fi
    make_link "$src" "$lnk"
}

# $* のファイルを${_backup_root}に移動する
backup_file() {
    local _target="$*"
    # バックアップ先のディレクトリがない場合は作成する
    make_dir_if_needed "$_backup_root"

    local _name="$(basename "$_target")"
    # バックアップ先ディレクトリにmv
    mexe "mv -fv \"$_target\" \"${_backup_root}/${_timestamp}.$_name\""
    del_if_exist "$_target"
    if [[ ! -e "$_target" ]]; then
        dlog "===> Backuped $_target"
    fi
}

# 存在する場合のみ削除
del_if_exist() {
    local rm_target="$*"
    if [ "$rm_target" = "/" ]; then
        log "invalid rm path $rm_target"
        return
    fi
    if isexist "$rm_target"; then
        mexe "rm -rf \"$rm_target\""
    fi
}

is_msys() { [[ "$DETECT_OS" == "msys" ]]; }
is_cygwin() { [[ "$DETECT_OS" == "cygwin" ]]; }
is_mac() { [[ "$DETECT_OS" == "mac" ]]; }
is_ubuntu() { [[ "$DETECT_OS" == "ubuntu" ]]; }
is_redhat() { [[ "$DETECT_OS" == "redhat" ]]; }
is_win() { is_msys || is_cygwin; }
is_unix() { ! is_win; }

make_work_if_needed() {
    make_dir_if_needed "$workdir"
}
cd_work() {
    make_work_if_needed
    mexe "cd \"$workdir\""
}
gh() {
    local url=$1
    local tag=${2:-}
    local repo_name=${url##*/}
    repo_name=${repo_name%%\.git}
    if [[ ! -e $workdir/$repo_name ]]; then
        mexe git clone $url $workdir/$repo_name
    fi
    cd_work
    mexe cd $repo_name
    mexe git fetch
    if [[ -n $tag ]]; then
        mexe git checkout -b $tag $tag
    fi
}
dl() {
    local _url="$1"
    local _dst="$2"
    if [[ $# -eq 1 ]]; then
        ! is_dry && log "===> Downloading from $_url"
        if has curl; then
            mexe "curl -fLO \"$_url\""
        else
            mexe "wget \"$_url\""
        fi
    else
        ! is_dry && log "===> Downloading from $_url to $_dst"
        if has curl; then
            mexe "curl -fL \"$_url\" -o \"$_dst\""
        else
            mexe "wget \"$_url\" -O \"$_dst\""
        fi
    fi
}
dl_unzip () {
    local url="$1"
    local to="${2}"
    cd_work
    dl "$url" dl.zip
    if [[ -n "$to" ]]; then
        mexe "unzip dl.zip -d \"$to\""
    fi
}

