#!/bin/bash

DOT_PATH=~/.dot
DETECT_OS=$($DOT_PATH/bin/os)
DETECT_BIT=$($DOT_PATH/bin/bit)
_timestamp=$(date +%Y%m%d%H%M%S)
_backup_dir="${DOT_PATH}/bkup/$_timestamp"
_log_file="${DOT_PATH}"/bkup/$_timestamp.setup.log
_dry_run_commands=""

# echo するのみ
log() {
    if [[ $dry_run -eq 1 ]]; then
        echo -e "$*"
    else
        echo -e "$*" |tee -a $_log_file
    fi
}
dlog() {
    [[ $debug -eq 1 ]] && log "$*"
    :
}

# コマンド実行
# log メソッドを呼びつつ実行する
vexec() {
    cmd="$*"
    dlog "===> Executing: $cmd"
    eval "$cmd" 2>&1 |tee -a $_log_file
    if [ ${PIPESTATUS[0]} -eq 0 ]; then
        dlog "    => Command Sucessfully."
    else
        dlog "    => Command Failed......"
    fi
}

# コマンドダミー実行
# echoするのみ
dry_vexec() {
    cmd="$*"
    dlog " Dummy Exec: $cmd"
}

# コマンドがインストールされているかチェックする
has() { which $1 >& /dev/null; }

# $* が存在するかどうか判定する
isexist() {
    local file="$*"
    local count=$(ls -a "$file" 2>/dev/null |wc -l|sed 's/ //g')
    [[ $count -eq 0 ]] && return 1
    return 0
}

# $1のファイルを$2へリンクを作成する
make_link() {
    local from=$1
    local to=$2
    dvexec "ln -s \"$from\" \"$to\""
}

# Dry run 実行用の関数定義
dvexec() {
    local cmd="$*"
    if [[ $dry_run -eq 1 ]]; then
        dry_vexec $cmd
        _dry_run_commands="$_dry_run_commands\n   For $app: $cmd"
    else
        vexec $cmd
    fi
}

# $* のリンクを 絶対パスで表示する（readlink -f の代用（For Mac））
# echo 結果がパスとして使用される為、log 実行時は正しく動作しない
readlink_path() {
    local target="$*"
    if [ "$target" = "" ]; then
        echo "Error!!! readlink_path Error!!!!!!!! argument is blank!!"
        return
    fi
    buf="`echo $target`"
    pre=""
    while [ "$buf" != "" ]; do
        pre="`echo $buf`"
        buf="`readlink "$buf"`"
    done
    echo "$pre"
}

# $* ディレクトリ配下の dot file をHOMEへリンクを作成する
make_link_dot2home() {
    local dir="$*"
    for file in `cd "$dir" && /bin/ls -a | grep -v ^.git$ | grep -v ^.gitignore$ | grep -v ^.gitkeep$ | egrep '^\.[^.]+'`; do
        make_lnk_with_bkup "$dir/$file" "${HOME}/$file"
    done
}

# 同じリンクかどうか
is_same_link() {
    local src1=$1
    local src2=$2
    if [ "$src1" = "$src2" ]; then
        return 1
    fi
    if [ "$src1/" = "$src2" ]; then
        return 1
    fi
    if [ "$src1" = "$src2/" ]; then
        return 1
    fi
    return 0
}

# $1のファイルを$2へリンクを作成する
make_lnk_with_bkup() {
    local src=$1
    local lnk=$2
    local need_backup=0
    # dlog " make_lnk_with_bkup Start lnk=$lnk src=$src"
    #if [ -e "${lnk}" ]; then
    if isexist "${lnk}"; then
        # dlog "   @@@@@@ exist!"
        # ファイルタイプ(ファイル、ディレクトリ、リンク)をチェック
        #if [ -n "`find "${lnk}" -maxdepth 0 -type l`" ]; then
        if [ -L "${lnk}" ]; then
            # リンク
            # dlog "   @@@@@@ Link!"
            local fullpath_lnk="`readlink_path "${lnk}"`"
            local fullpath_src="`readlink_path "${src}"`"
            # dlog "    lnk:$lnk => fullpath_lnk=$fullpath_lnk"
            # dlog "    src:$src => fullpath_src=$fullpath_src"
            if ! is_same_link "$fullpath_lnk" "$fullpath_src"; then
                # 既に自分へのリンクの場合はなにもしない
                # dlog "  => Already linked. Skip it. path=${lnk}"
                return 0
            else
                # 他ファイルへのリンクなのでバックアップする
                # dlog "  => Not match link. backup it. old link is ${fullpath_lnk} => new link is ${fullpath_src}"
                need_backup=1
            fi
        elif [ -d "${lnk}" ]; then
            # ディレクトリはバックアップする
            # dlog "   @@@@@@ Dir!"
            log "  => Directory exist. Backup it. path=$lnk"
            need_backup=1
        elif [ -f "${lnk}" ]; then
            # 既存のファイルをバックアップする
            # dlog "   @@@@@@ File!"
            log "  => File exist. Backup it. path=$lnk"
            need_backup=1
        else
            # dlog "   @@@@@@ little bit!"
            # ないと思う
            log "  => Little bit strange exist. path=${lnk} ... Do nothing"
            return 0
        fi
    fi
    # バックアップが必要ならバックアップする
    if [ $need_backup -eq 1 ]; then
        # dlog "   @@@@@@ Backup!"
        bkup_orig_file "${lnk}"
    fi
    make_link "$src" "$lnk"
}

# $* のファイルを${_backup_dir}に移動する
_bkup_files=""
bkup_orig_file() {
    local bkup_target="$*"
    # バックアップ先のディレクトリがない場合は作成する
    if [ ! -e "${_backup_dir}" ]; then
        dvexec "mkdir -p \"${_backup_dir}\""
    fi

    # バックアップ先ディレクトリにmv
    dvexec "mv -fv \"$bkup_target\" \"${_backup_dir}\"/"
    del_if_exist $bkup_target
    _bkup_files="$_bkup_files\n       $bkup_target"
}

dump_backuped_files() {
    if [[ -z $_bkup_files ]]; then
        return
    fi
    log "===================================================="
    log "==>  Below files is backuped to $_backup_dir.$_bkup_files"
    log "===================================================="
}

dump_run_commands() {
    if [[ -z $_dry_run_commands ]]; then
        return
    fi
    log "===================================================="
    log "==>  This is Dry-run mode."
    log "==>     Below commands will be execute."
    log $_dry_run_commands
    log "===================================================="
}

# 存在する場合のみ削除
del_if_exist() {
    local rm_target="$*"
    if [ "$rm_target" = "/" ]; then
        log "invalid rm path $rm_target"
        return
    fi
    if isexist "$rm_target"; then
        dvexec "rm -rf \"$rm_target\""
    fi
}

is_msys() { [[ "$DETECT_OS" == "msys" ]]; }
is_cygwin() { [[ "$DETECT_OS" == "cygwin" ]]; }
is_mac() { [[ "$DETECT_OS" == "mac" ]]; }
is_ubuntu() { [[ "$DETECT_OS" == "ubuntu" ]]; }
is_redhat() { [[ "$DETECT_OS" == "redhat" ]]; }
is_win() { is_msys || is_cygwin; }
is_unix() { ! is_win; }

make_work_if_needed() {
    if [[ ! -e "$workdir" ]]; then
        dvexec "mkdir -p \"$workdir\""
    fi
}
cd_work() {
    dvexec "cd \"$workdir\""
}
dl() {
    if [[ $# -eq 1 ]]; then
        log "===> Downloading from $1"
        # dvexec curl -fsSLO "$1"
        dvexec curl -fLO "$1"
    else
        # dvexec wget "$1" -O "$2"
        log "===> Downloading from $1 to $2"
        # dvexec curl -fsSL "$1" -o "$2"
        dvexec curl -fL "$1" -o "$2"
    fi
}

