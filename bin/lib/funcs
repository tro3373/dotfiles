#!/bin/bash

DOT_PATH=~/.dot
DETECT_OS=$($DOT_PATH/bin/os)
DETECT_BIT=$($DOT_PATH/bin/bit)
_timestamp=$(date +%Y%m%d%H%M%S)
_backup_dir="${DOT_PATH}/bkup/$_timestamp"
_log_file="${DOT_PATH}"/bkup/$_timestamp.setup.log

# echo するのみ
log() {
    if [[ -n $dry_run ]] && [[ $dry_run -eq 0 ]]; then
        echo -e "$*" |tee -a $_log_file
    else
        echo -e "$*"
    fi
}
dlog() { [[ $debug -eq 1 ]] && log "$*"; }

# コマンド実行
# log メソッドを呼びつつ実行する
vexec() {
    cmd="$*"
    dlog "===> Executing: $cmd"
    eval $cmd |tee -a $_log_file
    if [ $? -eq 0 ]; then
        dlog "    => Command Sucessfully."
    else
        dlog "    => Command Failed......"
    fi
}

# コマンドダミー実行
# echoするのみ
dry_vexec() {
    cmd="$*"
    dlog " Dummy Exec: $cmd"
}

# コマンドがインストールされているかチェックする
has() { which $1 >& /dev/null; }

# $* が存在するかどうか判定する
isexist() {
    local file="$*"
    local count=`ls -a "$file" 2>/dev/null |wc -l|sed 's/ //g'`
    if [ "$count" == "0" ]; then
        # 存在しない場合は bash 内で false の意味を表す 1 を応答する.
        return 1
    fi
    # 存在する場合は bash 内で true の意味を表す 0 を応答する.
    return 0
}

# $1のファイルを$2へリンクを作成する
make_link() {
    local from=$1
    local to=$2
    dvexec "ln -s \"$from\" \"$to\""
}

# Dry run 実行用の関数定義
dvexec() {
    local cmd="$*"
    if [ $dry_run -eq 0 ]; then
        vexec $cmd
    else
        dry_vexec $cmd
        dry_run_commands="$dry_run_commands\n Dummy Exec: $cmd"
    fi
}

# $* のリンクを 絶対パスで表示する（readlink -f の代用（For Mac））
# echo 結果がパスとして使用される為、log 実行時は正しく動作しない
readlink_path() {
    local target="$*"
    if [ "$target" = "" ]; then
        echo "Error!!! readlink_path Error!!!!!!!! argument is blank!!"
        return
    fi
    buf="`echo $target`"
    pre=""
    while [ "$buf" != "" ]; do
        pre="`echo $buf`"
        buf="`readlink "$buf"`"
    done
    echo "$pre"
}

# $* ディレクトリ配下の dot file をHOMEへリンクを作成する
make_link_dot2home() {
    local dir="$*"
    for file in `cd "$dir" && /bin/ls -a | grep -v ^.git$ | grep -v ^.gitignore$ | grep -v ^.gitkeep$ | egrep '^\.[^.]+'`; do
        make_lnk_with_bkup "$dir/$file" "${HOME}/$file"
    done
}

# 同じリンクかどうか
is_same_link() {
    local src1=$1
    local src2=$2
    if [ "$src1" = "$src2" ]; then
        return 1
    fi
    if [ "$src1/" = "$src2" ]; then
        return 1
    fi
    if [ "$src1" = "$src2/" ]; then
        return 1
    fi
    return 0
}

# $1のファイルを$2へリンクを作成する
make_lnk_with_bkup() {
    local src=$1
    local lnk=$2
    local need_backup=0
    dlog " make_lnk_with_bkup Start lnk=$lnk src=$src"
    #if [ -e "${lnk}" ]; then
    if isexist "${lnk}"; then
        # log "   @@@@@@ exist!"
        # ファイルタイプ(ファイル、ディレクトリ、リンク)をチェック
        #if [ -n "`find "${lnk}" -maxdepth 0 -type l`" ]; then
        if [ -L "${lnk}" ]; then
            # リンク
            # log "   @@@@@@ Link!"
            local fullpath_lnk="`readlink_path "${lnk}"`"
            local fullpath_src="`readlink_path "${src}"`"
            # log "    lnk:$lnk => fullpath_lnk=$fullpath_lnk"
            # log "    src:$src => fullpath_src=$fullpath_src"
            if ! is_same_link "$fullpath_lnk" "$fullpath_src"; then
                # 既に自分へのリンクの場合はなにもしない
                dlog "  => Already linked. Skip it. path=${lnk}"
                return 0
            else
                # 他ファイルへのリンクなのでバックアップする
                log "  => Not match link. backup it. old link is ${fullpath_lnk} => new link is ${fullpath_src}"
                need_backup=1
            fi
        elif [ -d "${lnk}" ]; then
            # ディレクトリはバックアップする
            # log "   @@@@@@ Dir!"
            log "  => Directory exist. Backup it. path=$lnk"
            need_backup=1
        elif [ -f "${lnk}" ]; then
            # 既存のファイルをバックアップする
            # log "   @@@@@@ File!"
            log "  => File exist. Backup it. path=$lnk"
            need_backup=1
        else
            # log "   @@@@@@ little bit!"
            # ないと思う
            log "  => Little bit strange exist. path=${lnk} ... Do nothing"
            return 0
        fi
    fi
    # バックアップが必要ならバックアップする
    if [ $need_backup -eq 1 ]; then
        # log "   @@@@@@ Backup!"
        bkup_orig_file "${lnk}"
    fi
    make_link "$src" "$lnk"
}

# $* のファイルを${_backup_dir}に移動する
_bkup_files=""
bkup_orig_file() {
    local bkup_target="$*"
    # バックアップ先のディレクトリがない場合は作成する
    if [ ! -e "${_backup_dir}" ]; then
        dvexec "mkdir -p \"${_backup_dir}\""
    fi

    # バックアップ先ディレクトリにmv
    dvexec "mv -fv \"$bkup_target\" \"${_backup_dir}\"/"
    del_if_exist $bkup_target
    _bkup_files="${_bkup_files}\nbackup to ${_backup_dir}/`basename "$bkup_target"`"
}

dump_backuped_files() {
    if [[ -n $_bkup_files ]]; then
        log "======================================>"
        log " Below files is backuped."
        log $_bkup_files
    fi
}

# 存在する場合のみ削除
del_if_exist() {
    local rm_target="$*"
    if [ "$rm_target" = "/" ]; then
        log "invalid rm path $rm_target"
        return
    fi
    if isexist "$rm_target"; then
        dvexec "rm -rf \"$rm_target\""
    fi
}

is_msys() { [[ "$DETECT_OS" == "msys" ]]; }
is_cygwin() { [[ "$DETECT_OS" == "cygwin" ]]; }
is_mac() { [[ "$DETECT_OS" == "mac" ]]; }
is_ubuntu() { [[ "$DETECT_OS" == "ubuntu" ]]; }
is_redhat() { [[ "$DETECT_OS" == "redhat" ]]; }
is_win() { is_msys || is_cygwin; }
is_unix() { ! is_win; }

