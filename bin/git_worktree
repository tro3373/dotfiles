#!/usr/bin/env -S bash -e

command_name=$(basename "$0") && readonly command_name
worktree_dir_suffix="worktree" && readonly worktree_dir_suffix
repo_root_label="RepositoryRoot" && readonly repo_root_label
readonly depends=(git fzf)
mode=list
branch=
commit_hash=
switch=0
args=()
usage() {
  cat <<EOF

Add a new git worktree for the specified branch(or Remove it).

  Usage:
      $command_name [option] <branch_name> <commit_hash>
    Options
      -h|--help : Show this usage
      -l        : List all worktrees with switch (default)
      -a        : Add a worktree for the specified branch
      -r        : Remove the worktree instead of adding it
      -e        : Edit config
      -sw       : Change directory
                    -a -sw: Switch to the newly added worktree directory

EOF
}
initialize() {
  while true; do
    [[ -z $1 ]] && break
    case "$1" in
      -h | --help) usage && exit 0 ;;
      -l) mode=list ;;
      -r) mode=remove ;;
      -a) mode=add ;;
      -e) mode=edit_config ;;
      -sw) switch=1 ;;
      *) add_args "$1" ;;
    esac
    shift
  done
  check
}
check() {
  hass "${depends[@]}"

  branch="${args[0]}"
  commit_hash="${args[1]}"

  if [[ $mode == "add" && -z $branch ]]; then
    cat <<EOF | ink red
==> Specify a branch name to add a worktree for.
==> Exiting branch is..

$(git branch -vv)

EOF
    exit 1
  fi
}
add_args() { args+=("$@"); }
has() { command -v "${1}" >&/dev/null; }
hass() { for arg in "$@"; do has "$arg" || elog "==> No $arg command exist."; done; }

get_org_git_root() {
  # NOTE: git rev-parse --git-common-dir: Get the common git directory path
  #   - this show               .git if in original repo root directory
  #   - this show            ../.git if in original repo sub-directory
  #   - this show /path/to/repo/.git if in worktree
  #   - this show            ../.git if in worktree sub-directory
  realpath "$(dirname "$(git rev-parse --git-common-dir)")"
}

get_worktree_branch_name() {
  # Replace slashes with hyphens for the branch name
  echo "${branch//\//-}"
}

show_change_directory_command() {
  _list_root_and_worktree_directories |
    fzf \
      --exit-0 \
      --no-multi \
      --reverse \
      --height=20% \
      --bind 'ctrl-l:toggle-all' \
      --prompt="Select worktree branches to change directory: " |
    awk '{print $NF}' |
    while read -r branch_path; do
      [[ -z $branch_path ]] && continue
      [[ $branch_path =~ ^#.* ]] && continue
      echo cd "$branch_path"
    done
}

_list_root_and_worktree_directories() {
  {
    # show worktrees sorted by updated time
    ls -td "$git_worktree_dir"/*/ 2>/dev/null || :
    # show repo root directory
    echo "$git_org_root_dir"
  } |
    while read -r _target_path; do
      [[ -z $_target_path ]] && continue
      [[ $_target_path =~ ^#.* ]] && continue
      label="($repo_root_label)"
      if [[ $_target_path =~ ^$git_worktree_dir/ ]]; then
        label=$(basename "$_target_path")
        local task_file="$_target_path/.tasks.md"
        if [[ -s $task_file ]]; then
          task_file_title=$(head -1 "$task_file" | sed -e 's,^#* ,,')
          if [[ -n $task_file_title ]]; then
            label="$label [${task_file_title}]"
          fi
        fi
      fi
      _time=$(stat -c %y "$_target_path" | cut -d. -f1 | sed -e 's, ,_,g')
      printf "%s\t%s\t%s\n" "$_time" "$label" "$_target_path"
    done | column -t -s $'\t'

}

_add_worktree() {
  if [[ ! -e $ln_config ]]; then
    wlog "==> No config file exist."
    read -r -n 1 -p "==> Create config file? (Y/n): "
    if ! [[ $REPLY =~ ^[Nn]$ ]]; then
      create_default_ln_config
    fi
  fi
  dst_dir="$git_worktree_dir/$(get_worktree_branch_name)"
  ilog "==> Adding worktree to $dst_dir for $branch branch hash:$commit_hash.."
  # shellcheck disable=SC2086
  git worktree add -b "$branch" "$dst_dir" $commit_hash 1>&2 || {
    elog "Failed to add worktree to $dst_dir for branch '$branch'."
  }
  ln_ignored_from_config 1>&2
  ilog "==> Added worktree for branch '$branch' at '$dst_dir'."

  if [[ $switch -ne 1 ]]; then
    # Log the directory and exit
    echo "$dst_dir"
    return
  fi
  # Change to the new worktree directory via cd command(handled by zsh)
  echo cd "$dst_dir"
}

ln_ignored_from_config() {
  [[ ! -e $ln_config ]] && {
    wlog "==> No config file exist. Skipping linking ignored files."
    return
  }
  cat <"$ln_config" |
    while read -r rel_path; do
      [[ -z $rel_path ]] && continue
      [[ $rel_path =~ ^#.* ]] && continue
      src="$git_org_root_dir/$rel_path"
      [[ ! -e $src ]] && {
        wlog "==> Ignored path '$rel_path' does not exist in the repository. Skipping linking."
        continue
      }
      dst="$dst_dir/$rel_path"
      _dst_dir="$(dirname "$dst")"
      [[ ! -e $_dst_dir ]] && mkdir -p "$_dst_dir"

      if [[ -f $src ]]; then
        # File case
        _ln "$src" "$dst"
        continue
      fi

      # Directory case
      mkdir -p "$dst"
      src="$(realpath "$src")" # Resolve to absolute path
      find "$src/" -maxdepth 1 -mindepth 1 |
        while read -r item_path; do
          item_name=$(basename "$item_path")
          _ln "$item_path" "$dst/$item_name"
        done || :
    done
}

_ln() {
  ilog "==> Linking via: ln -s '$1' '$2'"
  ln -s "$1" "$2"
}

create_default_ln_config() {
  git status --ignored --porcelain 2>/dev/null |
    grep '^!!' |
    grep -Ev '(\.tasks\.md|\.trash|node_modules|.next|tsconfig.tsbuildinfo|.data|-data)' |
    cut -c4- >"$ln_config"
  # fzf \
  #   --prompt="Select ignored files/directories to link in new worktree: " \
  #   --bind 'ctrl-l:toggle-all' \
  #   --reverse \
  #   --multi \
  #   --exit-0 >"$ln_config"
}

_remove_worktree() {
  removal_list=$(_list_removal_worktrees)
  if [[ -z $removal_list ]]; then
    elog "No worktrees exist to remove."
  fi

  force_remove=0
  _brach_path=
  while read -r branch_path _; do
    [[ -z $branch_path ]] && continue
    [[ $branch_path =~ ^#.* ]] && continue

    local task_file="$branch_path"/.tasks.md
    if [[ -s $task_file ]]; then
      absolute_path=$(realpath "$task_file")
      ilog "==> Moving task file '$task_file' to .tasks/done/.."
      mv "$absolute_path" "$git_org_root_dir/.tasks/done/"
    fi

    ilog "==> Removing worktree path: '$branch_path'.."
    git worktree remove "$branch_path" || {
      if [[ -e $branch_path ]]; then
        force_remove=1
        _brach_path="$branch_path"
      fi
    }
    # ilog "==> Removing branch '$branch_name'.."
    # git branch -d "$branch_name"
  done < <(
    _list_root_and_worktree_directories |
      grep -v "$repo_root_label" |
      fzf \
        --exit-0 \
        --multi \
        --reverse \
        --height=20% \
        --bind 'ctrl-l:toggle-all' \
        --prompt="Select branch to remove worktree for: " |
      awk '{print $NF " " $2}'
  )
  if [[ $force_remove -eq 1 ]]; then
    wlog "==> Worktree path '$_brach_path' still exist. Removing..(Cancel: Ctrl+C)"
    read -r _
    rm -rfv "$_brach_path"
  fi
}

_list_removal_worktrees() {
  git worktree list |
    grep "$git_worktree_dir"
}

_edit_config() {
  if [[ ! -e $ln_config ]]; then
    create_default_ln_config
  fi
  wlog "==> Editing config file.."
  echo "$ln_config" | v
}

main() {
  initialize "$@"

  git_org_root_dir=$(get_org_git_root)
  cd "$git_org_root_dir" || {
    elog "Failed to change directory to git root: $git_org_root_dir"
  }
  git_worktree_dir="${git_org_root_dir}-$worktree_dir_suffix"
  if [[ ! -e $git_worktree_dir ]]; then
    mkdir -p "$git_worktree_dir"
  fi
  local ln_config="$git_worktree_dir/config"

  if [[ $mode == "add" ]]; then
    _add_worktree
    return
  fi
  if [[ $mode == "remove" ]]; then
    _remove_worktree
    return
  fi
  if [[ $mode == "edit_config" ]]; then
    _edit_config
    return
  fi
  show_change_directory_command
}
main "$@"
