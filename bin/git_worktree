#!/usr/bin/env -S bash -e

command_name=$(basename "$0") && readonly command_name
worktree_dir_name="___$command_name" && readonly worktree_dir_name
readonly depends=(git fzf)
mode=list
branch=
commit_hash=
switch=0
args=()
usage() {
  cat <<EOF

Add a new git worktree for the specified branch(or Remove it).

  Usage:
      $command_name [option] <branch_name> <commit_hash>
    Options
      -h|--help : Show this usage
      -l        : List all worktrees with switch (default)
      -a        : Add a worktree for the specified branch
      -r        : Remove the worktree instead of adding it
      -e        : Edit ignore config
      -sw       : Change directory
                    -a -sw: Switch to the newly added worktree directory

EOF
}
initialize() {
  while true; do
    [[ -z $1 ]] && break
    case "$1" in
      -h | --help) usage && exit 0 ;;
      -l) mode=list ;;
      -r) mode=remove ;;
      -a) mode=add ;;
      -e) mode=edit_ignore ;;
      -sw) switch=1 ;;
      *) add_args "$1" ;;
    esac
    shift
  done
  check
}
check() {
  hass "${depends[@]}"

  branch="${args[0]}"
  commit_hash="${args[1]}"

  if [[ $mode == "add" && -z $branch ]]; then
    cat <<EOF | ink red
==> Specify a branch name to add a worktree for.
==> Exiting branch is..

$(git branch -vv)

EOF
    exit 1
  fi
}
add_args() { args+=("$@"); }
has() { command -v "${1}" >&/dev/null; }
hass() { for arg in "$@"; do has "$arg" || elog "==> No $arg command exist."; done; }

get_git_root() {
  # NOTE: Can not to use `git rev-parse` if current directory is in:
  #   - `/path/to/repo-root/.git/___git_worktree/`
  #   - `/path/to/repo-root/.tasks/`
  # git rev-parse --show-toplevel |
  pwd |
    sed -e "s,/.git/$worktree_dir_name.*,,g" -e 's,.tasks.*,,g'
}

get_worktree_branch_name() {
  # Replace slashes with hyphens for the branch name
  echo "${branch//\//-}"
}

show_change_directory_command() {
  _list_changeable_directories |
    fzf \
      --exit-0 \
      --no-multi \
      --reverse \
      --height=20% \
      --bind 'ctrl-l:toggle-all' \
      --prompt="Select worktree branches to change directory: " |
    awk '{print $NF}' |
    while read -r brach_path; do
      [[ -z $brach_path ]] && continue
      [[ $brach_path =~ ^#.* ]] && continue
      echo cd "$brach_path"
    done
}

_list_changeable_directories() {
  {
    # show worktrees sorted by updated time
    ls -td "$git_root_dir/.git/$worktree_dir_name"/*/ 2>/dev/null || :
    # show repo root directory
    echo "$git_root_dir"
  } |
    while read -r _target_path; do
      [[ -z $_target_path ]] && continue
      [[ $_target_path =~ ^#.* ]] && continue
      label="(RepositoryRoot)"
      if [[ $_target_path =~ ^$git_root_dir/.git/$worktree_dir_name/ ]]; then
        label=$(basename "$_target_path")
        local task_file="$_target_path/.tasks.md"
        if [[ -e $task_file ]]; then
          label=$(head -1 "$task_file" | sed -e 's,^#* ,,')
        fi
      fi
      _time=$(stat -c %y "$_target_path" | cut -d. -f1 | sed -e 's, ,_,g')
      printf "%s\t%s\t%s\n" "$_time" "$label" "$_target_path"
    done | column -t -s $'\t'

}

_add_worktree() {
  dst_dir="$git_root_dir/.git/$worktree_dir_name/$(get_worktree_branch_name)"
  ilog "==> Adding worktree to $dst_dir for $branch branch hash:$commit_hash.."
  # shellcheck disable=SC2086
  git worktree add -b "$branch" "$dst_dir" $commit_hash 1>&2 || {
    elog "Failed to add worktree to $dst_dir for branch '$branch'."
  }
  ln_ignored_if_needed 1>&2
  ilog "==> Added worktree for branch '$branch' at '$dst_dir'."

  if [[ $switch -ne 1 ]]; then
    # Log the directory and exit
    echo "$dst_dir"
    return
  fi
  # Change to the new worktree directory via cd command(handled by zsh)
  echo cd "$dst_dir"
}

ln_ignored_if_needed() {
  if [[ ! -e $ln_ignored_config ]]; then
    wlog "==> No .ln_ignored config file exist."
    read -r -n 1 -p "==> Create config file? (Y/n): "
    if [[ $REPLY =~ ^[Nn]$ ]]; then
      wlog "==> Skipping linking ignored files."
      return
    fi
    create_default_ln_ignored_config
  fi
  ln_ignored_from_config
}

ln_ignored_from_config() {
  cat <"$ln_ignored_config" |
    while read -r rel_path; do
      [[ -z $rel_path ]] && continue
      [[ $rel_path =~ ^#.* ]] && continue
      src="$git_root_dir/$rel_path"
      [[ ! -e $src ]] && {
        wlog "==> Ignored path '$rel_path' does not exist in the repository. Skipping linking."
        continue
      }
      src_is_file=0
      [[ -f $src ]] && src_is_file=1
      dst="$dst_dir/$rel_path"
      # dst=${dst%/}
      _dst_dir="$(dirname "$dst")"
      [[ ! -e $_dst_dir ]] && mkdir -p "$_dst_dir"
      [[ $src_is_file -eq 1 ]] && _ln "$src" "$dst" && continue
      mkdir -p "$dst"
      find "$src" -maxdepth 1 -mindepth 1 |
        while read -r item_path; do
          item_name=$(basename "$item_path")
          _ln "$item_path" "$dst/$item_name"
        done || :
    done
}

_ln() {
  ilog "==> Linking via: ln -s '$1' '$2'"
  ln -s "$1" "$2"
}

create_default_ln_ignored_config() {
  git status --ignored --porcelain 2>/dev/null |
    grep '^!!' |
    grep -Ev '(\.tasks\.md|\.trash|node_modules|.next)' |
    cut -c4- >"$ln_ignored_config"
  # fzf \
  #   --prompt="Select ignored files/directories to link in new worktree: " \
  #   --bind 'ctrl-l:toggle-all' \
  #   --reverse \
  #   --multi \
  #   --exit-0 >"$ln_ignored_config"
}

_remove_worktree() {
  removal_list=$(_list_removal_worktrees)
  if [[ -z $removal_list ]]; then
    elog "No worktrees exist to remove."
  fi

  _list_removal_worktrees |
    fzf \
      --exit-0 \
      --multi \
      --reverse \
      --height=20% \
      --bind 'ctrl-l:toggle-all' \
      --prompt="Select branch to remove worktree for: " |
    while read -r brach_path _ branch_name; do
      [[ -z $brach_path ]] && continue
      [[ $brach_path =~ ^#.* ]] && continue

      local task_file="$brach_path"/.tasks.md
      if [[ -e $task_file ]]; then
        linked_path=$(readlink "$task_file")
        ilog "==> Moving task file '$task_file' to .tasks/done/.."
        mv "$linked_path" "$brach_path/.tasks/done/"
      fi

      # Remove []: ex [feature/xxxx] => feature/xxxx
      branch_name=${branch_name//[\[\]]/}
      ilog "==> Removing worktree path: '$brach_path'.."
      git worktree remove "$brach_path"
      # ilog "==> Removing branch '$branch_name'.."
      # git branch -d "$branch_name"
    done
}

_list_removal_worktrees() {
  git worktree list |
    grep "$worktree_dir_name"
}

_edit_ignore() {
  if [[ ! -e $ln_ignored_config ]]; then
    create_default_ln_ignored_config
  fi
  wlog "==> Editing .ln_ignored config file.."
  echo "$ln_ignored_config" | v
}

main() {
  initialize "$@"

  git_root_dir=$(get_git_root)
  cd "$git_root_dir" || {
    elog "Failed to change directory to git root: $git_root_dir"
  }

  local ln_ignored_config="$git_root_dir/.git/$worktree_dir_name/.ln_ignored"

  if [[ $mode == "add" ]]; then
    _add_worktree
    return
  fi
  if [[ $mode == "remove" ]]; then
    _remove_worktree
    return
  fi
  if [[ $mode == "edit_ignore" ]]; then
    _edit_ignore
    return
  fi
  show_change_directory_command
}
main "$@"
