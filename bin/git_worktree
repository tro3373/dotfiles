#!/usr/bin/env -S bash -e

command_name=$(basename "$0") && readonly command_name
worktree_dir_name="___$command_name" && readonly worktree_dir_name
readonly depends=(git fzf)
mode=list
branch=
commit_hash=
switch=0
args=()
usage() {
  cat <<EOF

Add a new git worktree for the specified branch(or Remove it).

  Usage:
      $command_name [option] <branch_name> <commit_hash>
    Options
      -h|--help : Show this usage
      -l        : List all worktrees with switch (default)
      -a        : Add a worktree for the specified branch
      -r        : Remove the worktree instead of adding it
      -sw       : Change directory
                    -a -sw: Switch to the newly added worktree directory

EOF
}
initialize() {
  while true; do
    [[ -z $1 ]] && break
    case "$1" in
      -h | --help) usage && exit 0 ;;
      -l) mode=list ;;
      -r) mode=remove ;;
      -a) mode=add ;;
      -sw) switch=1 ;;
      *) add_args "$1" ;;
    esac
    shift
  done
  check
}
check() {
  hass "${depends[@]}"

  branch="${args[0]}"
  commit_hash="${args[1]}"

  if [[ $mode == "add" && -z $branch ]]; then
    cat <<EOF | ink red
==> Specify a branch name to add a worktree for.
==> Exiting branch is..

$(git branch -vv)

EOF
    exit 1
  fi
}
add_args() { args+=("$@"); }
has() { command -v "${1}" >&/dev/null; }
hass() { for arg in "$@"; do has "$arg" || elog "==> No $arg command exist."; done; }

get_git_root() {
  # NOTE: Can not to use `git rev-parse` if current directory is in:
  #   - `/path/to/repo-root/.git/___git_worktree/`
  #   - `/path/to/repo-root/.tasks/`
  # git rev-parse --show-toplevel |
  pwd |
    sed -e "s,/.git/$worktree_dir_name.*,,g" -e 's,.tasks.*,,g'
}

get_worktree_branch_name() {
  # Replace slashes with hyphens for the branch name
  echo "${branch//\//-}"
}

show_change_directory_command() {
  _list_changeable_directories |
    fzf \
      --exit-0 \
      --no-multi \
      --reverse \
      --height=20% \
      --bind 'ctrl-l:toggle-all' \
      --prompt="Select worktree branches to change directory: " |
    awk '{print $NF}' |
    while read -r brach_path; do
      [[ -z $brach_path ]] && continue
      [[ $brach_path =~ ^#.* ]] && continue
      echo cd "$brach_path"
    done
}

_list_changeable_directories() {
  {
    # show worktrees sorted by updated time
    ls -td "$git_root_dir/.git/$worktree_dir_name"/*/ 2>/dev/null || :
    # show repo root directory
    echo "$git_root_dir"
  } |
    while read -r _target_path; do
      [[ -z $_target_path ]] && continue
      [[ $_target_path =~ ^#.* ]] && continue
      label="RepositoryRoot"
      if [[ $_target_path =~ ^$git_root_dir/.git/$worktree_dir_name/ ]]; then
        label=$(basename "$_target_path")
        local task_file="$_target_path/.tasks.md"
        if [[ -e $task_file ]]; then
          label=$(head -1 "$task_file" | sed -e 's,^#* ,,')
        fi
      fi
      _time=$(stat -c %y "$_target_path" | cut -d. -f1 | sed -e 's, ,_,g')
      printf "%s\t%s\t%s\n" "$_time" "$label" "$_target_path"
    done | column -t -s $'\t'

}

add_worktree() {
  dst_dir="$git_root_dir/.git/$worktree_dir_name/$(get_worktree_branch_name)"
  ilog "==> Adding worktree to $dst_dir for $branch branch hash:$commit_hash.."
  # shellcheck disable=SC2086
  git worktree add -b "$branch" "$dst_dir" $commit_hash 1>&2 || {
    elog "Failed to add worktree to $dst_dir for branch '$branch'."
  }
  ln_ignored_if_needed 1>&2
  ilog "==> Added worktree for branch '$branch' at '$dst_dir'."

  if [[ $switch -ne 1 ]]; then
    # Log the directory and exit
    echo "$dst_dir"
    return
  fi
  # Change to the new worktree directory via cd command(handled by zsh)
  echo cd "$dst_dir"
}

ln_ignored_if_needed() {
  # Get ignored files/directories (directories shown with trailing /)
  git status --ignored --porcelain 2>/dev/null |
    grep '^!!' |
    cut -c4- |
    grep -Ev '(\.tasks\.md|\.trash)' |
    sed -e 's,/$,,g' |
    while read -r line; do
      [[ -z $line ]] && continue
      [[ $line =~ ^#.* ]] && continue
      src="$git_root_dir/$line"
      # src="../../../${line/.*\//../}" # TODO Test
      dst="$dst_dir/$line"
      dst_ln_dir="$(dirname "$dst")"
      [[ ! -e $dst_ln_dir ]] && mkdir -p "$dst_ln_dir"
      ilog "==> Linking $line"
      ln -s "$src" "$dst"
    done
}

remove_worktree() {
  removal_list=$(_list_removal_worktrees)
  if [[ -z $removal_list ]]; then
    elog "No worktrees exist to remove."
  fi

  _list_removal_worktrees |
    fzf \
      --exit-0 \
      --multi \
      --reverse \
      --height=20% \
      --bind 'ctrl-l:toggle-all' \
      --prompt="Select branch to remove worktree for: " |
    while read -r brach_path _ branch_name; do
      [[ -z $brach_path ]] && continue
      [[ $brach_path =~ ^#.* ]] && continue

      local task_file="$brach_path"/.tasks.md
      if [[ -e $task_file ]]; then
        linked_path=$(readlink "$task_file")
        ilog "==> Moving task file '$task_file' to .tasks/done/.."
        mv "$linked_path" "$brach_path/.tasks/done/"
      fi

      # Remove []: ex [feature/xxxx] => feature/xxxx
      branch_name=${branch_name//[\[\]]/}
      ilog "==> Removing worktree path: '$brach_path'.."
      git worktree remove "$brach_path"
      # ilog "==> Removing branch '$branch_name'.."
      # git branch -d "$branch_name"
    done
}

_list_removal_worktrees() {
  git worktree list |
    grep "$worktree_dir_name"
}

main() {
  initialize "$@"

  git_root_dir=$(get_git_root)
  cd "$git_root_dir" || {
    elog "Failed to change directory to git root: $git_root_dir"
  }

  if [[ $mode == "add" ]]; then
    add_worktree
    return
  fi
  if [[ $mode == "remove" ]]; then
    remove_worktree
    return
  fi
  show_change_directory_command
}
main "$@"
