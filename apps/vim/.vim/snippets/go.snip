###############################################################################
# Log
###############################################################################
# snippet	loglnnn
# 	fmt.Println("${1}", ${2})
# snippet	logfff
# 	fmt.Printf("${1}\n")
# snippet	logvvv
# 	fmt.Printf("%#+v\n", ${1})
# snippet	logerrr
# 	fmt.Printf("Failed to ${2}. Err:%+v\n", err)
# snippet debuggg
# 	const DEBUG = true
# 	func debug(a ...any) {
# 		if !DEBUG {
# 			return
# 		}
# 		// fmt.Fprintln(os.Stderr, a...)
# 		log.Debugf("%+v", a...)
# 	}
# snippet	custom_prefix_writerrr
# 	type customWriter struct {
# 		io.Writer
# 		timeFormat string
# 	}
# 	func (w customWriter) Write(b []byte) (n int, err error) {
# 		return w.Writer.Write(append([]byte(time.Now().Format(w.timeFormat)), b...))
# 	}
# 	logger := log.New(&customWriter{os.Stderr, "2006/01/02 15:04:05"}, ${1:prefix}, 0)

# snippet	log_newww
# 	log.New(os.Stderr, "", log.LstdFlags)
snippet	log_newww
	// [Goのslog使い方まとめ #AdventCalendar2023 - Qiita](https://qiita.com/Imamotty/items/3fbe8ce6da4f1a653fae)
	// # Set level
	// var lvl = new(slog.LevelVar)
	// lvl.Set(slog.LevelDebug)
	// logger := slog.New(slog.NewJSONHandler(os.Stdout, &slog.HandlerOptions{Level: lvl}))
	// // change level
	// lvl.Set(slog.LevelDebug)
	// # With attributes
	// logger := slog.New(slog.NewJSONHandler(os.Stdout, nil)).With("url", "https://example.com")
	// req := slog.Group("request", "method", "GET", "url", "https://example.com")
	// logger := slog.New(slog.NewJSONHandler(os.Stdout, nil)).With(req)
	// // 多段の階層構造
	// attrs := slog.Group("attrs", slog.Group("attr1", "hoge", "fuga"), slog.Group("attr2", "hoge", "fuga"))
	// Infoメソッドに直接渡す
	// logger.Info("Hello, World!", attrs)
	logger := slog.New(slog.NewJSONHandler(os.Stdout, nil))
	slog.SetDefault(logger)


snippet	ppp
	func p(a ...interface{}) {
		// fmt.Println(a...)
		log.Infof("%+v", a...)
	}

snippet	zap_newww
	logger, err := zap.NewProduction()

snippet	logrus_newww
	import log "github.com/sirupsen/logrus"
	// initConfigInner
	level, err := log.ParseLevel(os.Getenv("LOG_LEVEL"))
	if err == nil {
		log.SetLevel(level)
	}
	log.Infof("==> File:%s", file)

###############################################################################
# Error
###############################################################################
# See [今goのエラーハンドリングを無難にしておく方法（2021.09現在）](https://zenn.dev/nekoshita/articles/097e00c6d3d1c9)
# - stacktraceが不要な場合
#   - fmt.Errorfでラップし、errors.Isで判定する
# - stacktraceが必要な場合
#   - pkg/errors.Wrapでラップし、pkg/errors.Causeで判定する
#   - log.Printf("%+v", err)でstacktraceを出力する
#   - 新しいエラーを返す時はpkg/errors.New or pkg/errors.Errorfを使う

# Use standard library version.
# - Refs:
#   - [Go 1.20 Wrapping multiple errors | フューチャー技術ブログ](https://future-architect.github.io/articles/20230126a/)
snippet	iferrr
	if err != nil {
		return fmt.Errorf("failed to ${1:#do somthing}. %w", err)
	}
snippet	errr
alias	newerrr
	errors.New("Failed to ${1:#do somthing}")
snippet	errjoinn
alias	joinerrr
	errors.Join(err, errors.New("Failed to ${1:#do somthing}"))

# # Use efficientgo/core/errors version.
# snippet	iferrwww
# 	if err != nil {
# 		return errors.Wrap(err, "Failed to ${1:#do somthing}")
# 	}

# snippet	iferrwwwf
# 	if err != nil {
# 		return errors.Wrapf(err, "Failed to ${1:#do somthing}. %s", slog.String("${2:#key}", "${3:#value}"))
# 	}

# snippet	errors_newww
# alias	new_errorsss
# 	errors.New("Failed to ${1:#do somthing}")

# snippet	errors_newwwf
# alias	new_errorsssf
# 	errors.Errorf("Failed to ${1:#do somthing}. %s", slog.String("${2:#key}", "${3:#value}"))

# snippet	errors_wrapppf
# 	errors.Wrapf(err, "Failed to ${1:#do somthing}. %s", slog.String("${2:#key}", "${3:#value}"))

# snippet import_errorsss
# 	import "github.com/efficientgo/core/errors"
# 	fmt.Printf("Error: %+v", err)

# snippet	errors_samplesss
# 	# With Stack
# 	errors.New("Error")
# 	errors.Errorf("Error: %s", "${1}")
# 	# With Stack and Wrap
# 	errors.WithStack(err)
# 	errors.Wrapf(err, "Failed to somthing %s", "arg")
# 		if errors.Cause(err) == SampleError { }
# 	# No Stack
# 	fmt.Errorf("Failed to somthing. Error: %w", err)
# 		if errors.Is(err, SampleError) { }

snippet	defer_wrappp
	func Wrap(errp *error, format string, args ...any) {
		if *errp != nil {
				*errp = fmt.Errorf("%s: %w", fmt.Sprintf(format, args...), *errp)
		}
	}
	var ErrNotFound = errors.New("not found")
	func f(input int) (err error) {
			defer Wrap(&err, "f(%d)", input)
			if input == 0 {
					return ErrNotFound
			}
			return nil
	}


###############################################################################
# File
###############################################################################
snippet mk_dirrr
	os.Mkdir(${1}, 0775) //#nosec G301
snippet mk_diralll
	os.MkdirAll(${1}, 0775) //#nosec G301
snippet rm_dirrr
	err := os.Remove(${1})
snippet rm_dir_alll
	err := os.RemoveAll(${1})
snippet move_fileee
	func MoveFile(src, dst string) error {
		// 移動先のディレクトリを確認/作成
		destDir := filepath.Dir(dst)
		if err := os.MkdirAll(destDir, 0750); err != nil {
			return errors.Wrapf(err, "failed to create destination directory")
		}

		// まずRenameを試みる
		err := os.Rename(src, dst)
		if err == nil {
			return nil
		}

		// Renameが失敗した場合は、コピー＆削除を試みる
		source, err := os.Open(filepath.Clean(src))
		if err != nil {
			return errors.Wrapf(err, "failed to open source file")
		}
		defer source.Close()

		destination, err := os.Create(filepath.Clean(dst))
		if err != nil {
			return errors.Wrapf(err, "failed to create destination file")
		}
		defer destination.Close()

		// コピー
		if _, err := io.Copy(destination, source); err != nil {
			return errors.Wrapf(err, "failed to copy file")
		}

		// 元ファイルを削除
		if err := os.Remove(src); err != nil {
			return errors.Wrapf(err, "failed to remove source file")
		}

		return nil
	}
snippet touchhh
	func touch(path string) error {
		_, err := os.Stat(path)
		if os.IsNotExist(err) {
			file, err := os.Create(filepath.Clean(path))
			if err != nil {
				return err
			}
			defer file.Close()
			return nil
		}
		currentTime := time.Now().Local()
		err = os.Chtimes(path, currentTime, currentTime)
		if err != nil {
			return err
		}
		return nil
	}
snippet	file_write_jsonnn
alias		write_file_jsonnn
	file, _ := json.MarshalIndent(data, "", " ")
	_ = os.WriteFile("test.json", file, 0664) //#nosec G306
snippet	file_read_jsonnn
alias		read_file_jsonnn
	raw, err := os.ReadFile(filepath.Clean("test.json"))
	if err != nil {
		fmt.Println(err.Error())
		os.Exist(1)
	}
	var s SampleStruct
	json.Unmarshal(raw, &s)
snippet	file_writeee
alias		write_fileee
	func WriteFile(filePath, data string) error {
		return os.WriteFile(filePath, []byte(data), 0664) //#nosec G306
	}
snippet	file_read_if_existttt
alias		read_file_if_existtt
	func ReadFileIfExist(filePath string) (string, error) {
		if len(filePath) == 0 || !Exists(filePath) {
			return "", nil
		}
		raw, err := os.ReadFile(filepath.Clean(filePath))
		if err != nil {
			return "", err
		}
		return string(raw), nil
	}
snippet	open_fileee
	file, err := os.OpenFile(filepath.Clean(${1}), os.O_RDWR|os.O_CREATE|os.O_APPEND, 0664)  //#nosec G306
	// file, err := os.OpenFile(filepath.Clean($1), os.O_WRONLY|os.O_CREATE|os.O_TRUNC, 0664)  //#nosec G306
	if err != nil {
		return fmt.Errorf("failed to OpenFile %s, %w", $1, err)
	}
	defer file.Close()

snippet	ls_dirrr
	files, err := os.ReadDir(".")

snippet	file_pathhh
	files, err := filepath.Glob("./*/*/*.md")

snippet	file_readdd
	func useBufioScanner(fileName string) {
		 fp, err := os.Open(filepath.Clean(fileName))
		 if err != nil {
		 	panic(err)
		 }
		 defer fp.Close()

		scanner := bufio.NewScanner(fp)
		for scanner.Scan() {
			fmt.Println(scanner.Text())
		}
	}
snippet	file_sizeee
	func getFileSize(filePath string) (int64, error) {
		info, err := os.Stat(filePath)
		if err != nil {
			return -1, err
		}
		return info.Size(), nil
	}

snippet	current_dirrr
	pwd, err := os.Getwd()
	if err != nil {
		return err
	}
snippet	bin_dirrr
alias	script_dirrr
	ex, err := os.Executable()
	if err != nil {
		return err
	}
	exPath := filepath.Dir(ex)

snippet	is_empty_dirrr
alias	empty_dirrr
	func IsEmptyDir(dirPath string) (bool, error) {
		f, err := os.Open(filepath.Clean(dirPath))
		if err != nil {
			return false, err
		}
		defer f.Close()
		_, err = f.Readdirnames(1)
		if err == io.EOF {
			return true, nil
		}
		if err != nil {
			return false, err
		}
		return false, nil
	}
snippet	existsss
	func exists(path string) bool {
		_, err := os.Stat(path)
		return !os.IsNotExist(err)
	}

snippet	exists_prefixxx
	func existsPrefix(name string) (bool, error) {
		matches, err := filepath.Glob(name + ".*")
		if err != nil {
				return false, err
		}
		return len(matches) > 0, nil
	}

snippet	read_yamlsss
	import (
		"errors"
		"io/ioutil"
		"gopkg.in/yaml.v3"
	)
	type Config struct {
		Sample struct {
			Username          string \`yaml:"username"\`
			Password          string \`yaml:"password"\`
		} \`yaml:"sample"\`
	}

	func NewConfig(args []string) (*Config, error) {
		merged, err := mergeYamls(args[1:])
		if err != nil {
			return nil, err
		}
		b, err := yaml.Marshal(merged)
		if err != nil {
			return nil, err
		}
		var config Config
		err = yaml.Unmarshal(b, &config)
		return &config, err
	}

	func mergeYamls(args []string) (map[string]interface{}, error) {
		if len(args) == 0 {
			return nil, errors.New("=> Specify yaml path")
		}

		var err error
		var merged map[string]interface{}
		for _, arg := range args {
			data, err := readYaml(arg)
			if err != nil {
				return nil, err
			}
			if merged == nil {
				merged = data
				continue
			}
			merged, err = mergeMap(merged, data)
			if err != nil {
				return nil, err
			}
		}
		return merged, err
	}

	func readYaml(path string) (map[string]interface{}, error) {
		b, err := os.ReadFile(path)
		if err != nil {
			return nil, err
		}
		var data map[string]interface{}
		err = yaml.Unmarshal(b, &data)
		return data, err
	}

snippet read_csvvv
	import "encoding/csv"
	func readTsv(filePath string) error {
		file, err := os.Open(filePath)
		if err != nil {
			return err
		}
		defer file.Close()

		reader := csv.NewReader(file)
		reader.Comma = '\t'
		reader.Comment = '#'
		for {
			record, err := reader.Read()
			if err == io.EOF {
				break
			}
			if err != nil {
				return err
			}
			fmt.Println(record)
		}
	}

###############################################################################
# Date&Time
###############################################################################

snippet	time_formattt
	"20060102_150405"

snippet	time_nowww
alias	nowww
alias	timestamppp
	now := time.Now().Format("20060102_150405")

snippet	time_frommm
alias	time_parseee
	t, _ := time.Parse("20060102_150405", "20141231_000000")

snippet	time_unixxx
	t := time.Unix(${1}, 0)

snippet	first_and_last_day_of_monthhh
	now := time.Now()
	currentYear, currentMonth, _ := now.Date()
	currentLocation := now.Location()
	firstOfMonth := time.Date(currentYear, currentMonth, 1, 0, 0, 0, 0, currentLocation)
	lastOfMonth := firstOfMonth.AddDate(0, 1, -1)

###############################################################################

snippet	if_stringer
	if v, ok := ${1:interface}.(fmt.Stringer); ok {
		${2}
	}


snippet	reflect_isnil_or_pointer
	rv := reflect.ValueOf(${1})
	if rv.Kind() == reflect.Ptr || rv.IsNil() {
		${2}
	}

snippet	context_with_cancel
	ctx,  cancel  :=  context.WithCancel(context.Background())
	defer cancel()

snippet	context_with_timeout
	ctx, cancel := context.WithTimeout(context.Background(), Timeout)
	defer cancel()

snippet	cancel_context
	package  main
	import (
		"fmt"
		"sync"
		"context"
	)
	var wg sync.WaitGroup
	func main() {
		//  キャンセルするためのContextを生成
		ctx,  cancel  :=  context.WithCancel(context.Background())
		queue  :=  make(chan  string)
		for i  :=  0; i <  2; i++ {
			wg.Add(1)
			go  fetchURL(ctx,  queue)
		}
		queue  <-  "https://www.example.com"
		queue  <-  "https://www.example.net"
		queue  <-  "https://www.example.net/foo"
		queue  <-  "https://www.example.net/bar"
		cancel()   //  ctxを終了させる
		wg.Wait()  //  すべてのgoroutineが終了するのを待つ
	}
	func fetchURL(ctx  context.Context,  queue  chan  string) {
		for {
			select {
			case  <-ctx.Done():
				fmt.Println("worker  exit")
				wg.Done()
				return
			case  url  :=  <-queue:
				//  URL取得処理
			}
		}
	}

snippet	fetchurl
	func fetchURL(queue  chan  string,  done  chan  bool) {
		for url :=  range  queue {
			// url取得処理
		}
		fmt.Pritln("worker  exit")
		done <- true
	}

snippet	randam_int
	func getRandomNo(num int64) int64 {
		// 暗号学的に安全な乱数を生成. numは生成する乱数の上限
		// WARN: No use math/rand in production code, use crypto/rand instead.
		// rand.Intn(10)
		n, err := rand.Int(rand.Reader, big.NewInt(num))
		if err != nil {
			// 実質ほぼ全てのプラットフォームでcrypto/randバックエンドは失敗することがほとんどない
			// https://github.com/golang/go/issues/66821
			panic(err)
		}
		return n.Int64()
	}

snippet	randam_sleep
	time.Sleep(time.Duration(rand.Intn(2000)) * time.Millisecond)

snippet	sleeppp
alias	waitttt
	time.Sleep(time.Duration(1) * time.Millisecond)

snippet	select_channel
	select {
	case res := <-c1:
		fmt.Println(res)
	case <-time.After(1 * time.Second):
		fmt.Println("timeout 1")
	}

# http://engineerspirit.com/2017/01/22/post-637/
snippet	stringgg
abbr		add struct string func
options	word
  func ${1:#:(s S)} String() string {
    return fmt.Sprintf("${2}")
  }

snippet	structtt
alias	typeee
	type ${1:#struct_name} struct {
		${2:#variable} ${3:#type}
	}

snippet	struct_jsonnn
	type ${1} struct {
	 	// json:<マッピングするJSONオブジェクトのフィールド名>,<オプション> という形式で記述します
	 	// omitempty   0値(空文字、0、nil等)であればフィールドを出力しない   0値であれば無視される                                            json:"field,omitempty"
	 	// -           出力しない                                            無視される                                                       json:"-"
	 	// string      出力時に Quote される                                 Quoteされていても型に合わせて変換する。Quoteされてないとエラー   json:"field,string"
	 	${2} string \`json:"${3},string"\`
	}

snippet	fmtprint_samplesss
alias	print_samplesss
	// https://qiita.com/rock619/items/14eb2b32f189514b5c3c
	// verb
	fmt.Printf("%v\n", ${1}) // Output default format for the value.
	fmt.Printf("%+v\n", ${1}) // Output with field name
	fmt.Printf("%#v\n", ${1}) // Output with golang type spec format
	fmt.Printf("%#+v\n", ${1}) // Output with field name and type spec
	fmt.Printf("%T\n", ${1}) // Output The type
	fmt.Printf("%%\n", ${1}) // Output '%'
	// %s: string
	// %p: pointer or channel
	// %t: bool
	// %d: decimal number
	// %b: binary number
	// %o: octal number
	// %x: hexa decimal number
	// %c: word for unicode point
	// %q: Quoted value
	// %b: no decimal point index
	// %e: index
	// %E: Show large 'E'
	// %f: no index (same as %F) 指数表記なし 浮動小数点
	// %g: lage index then %e else %f
	// %G: lage index then %E else %F

snippet	func_newww
	func New${1}() *$1 {
		return &$1{}
	}

snippet	strconv_itoaaa
alias	itoaaa
	strconv.Itoa(${1})

snippet	strconv_atoiii
alias	atoiii
	// 10: 10進数
	// 64: 64bit整数
	timeout, err := strconv.ParseInt(${1}, 10, 64)

snippet	exec_run
	err := exec.Command("ls", "-la").Run()

snippet	exec_out
	out, err := exec.Command("ls", "-la").Output()

snippet	exec_start
	cmd := exec.Command("sleep", "5s")
	cmd.Start()
	fmt.Println("sleep中: ", time.Now().Format("15:04:05"))
	cmd.Wait()

snippet	getenvvv
	func getEnv(key, fallback string) string {
		if value, ok := os.LookupEnv(key); ok {
				return value
		}
		return fallback
	}

snippet	factoryyyy
	package factory

	import (
		"strings"
		"sync"
	)

	type Factory interface {
		New(name string) (interface{}, bool)
	}

	var (
		mu        sync.RWMutex
		factories = make(map[string]Factory)
	)

	func Register(pkgName string, f Factory) {
		mu.Lock()
		defer mu.Unlock()

		if f == nil {
			panic("Factory is nil")
		}
		if _, exist := factories[pkgName]; exist {
			panic("Factory already registered")
		}

		factories[pkgName] = f
	}

	func New(typeName string) (interface{}, bool) {
		items := strings.Split(typeName, ".")
		if len(items) >= 2 {
			mu.RLock()
			defer mu.RUnlock()
			if f, exist := factories[items[0]]; exist {
				return f.New(items[1])
			}
		}
		return nil, false
	}
	// ==========================================================================
	package pkga

	import "path/to/your/factory"

	type thisFactory struct {
	}

	type Alpha struct{}
	type Beta struct{}
	type Gamma struct{}

	func (f *thisFactory) New(name string) (interface{}, bool) {
		switch name {
		case "Alpha":
			return &Alpha{}, true
		case "Beta":
			return &Beta{}, true
		case "Gamma":
			return &Gamma{}, true
		}
		return nil, false
	}

	func init() {
		factory.Register("pkga", &thisFactory{})
	}
	// ==========================================================================
	package main

	import (
		"fmt"

		"path/to/your/factory"
		_ "path/to/custom/pkga"
		_ "path/to/custom/pkgb"
		//add more packages ...
	)

	func main() {
		 a, _ := factory.New("pkga.Alpha")
		 b, _ := factory.New("pkgb.Beta")
		 c, _ := factory.New("pkga.Gamma")

		 fmt.Printf("%T %T %T\n", a, b, c)
	}

snippet	mutexxx
alias	rw_mutexxx
	var (
		mu sync.RWMutex
	)
	mu.Lock()
	defer mu.Unlock()
	mu.RLock()
	defer mu.RUnlock()

snippet	float_stringgg
	strconv.FormatFloat(target, 'f', -1, 64)

snippet	sorttt
	sort.Slice(files, func(i, j int) bool {
		return files[i].Name() > files[j].Name()
	})

snippet reggg
	func reg(str string) *regexp.Regexp {
		return regexp.MustCompile(str)
	}
	str = reg(\`^.*//(.*)/(.*)\`).ReplaceAllString(str, "\$2\$1")

snippet	regexppp
alias	matchstringgg
	r := regexp.MustCompile(\`abc\`)
	fmt.Println(r.MatchString("hello"))

snippet	replace_all_regexppp
	r := regexp.MustCompile(\`abc\`)
	res := r.ReplaceAllString(str, "yyy")

snippet	replaceeee
	strings.Replace(str, "Src", "Dst", -1)

snippet	containsss
	import "golang.org/x/exp/slices"
	slices.Contains([]string{"a", "b", "c"}, "b")
snippet	containsss_manual
	func Contains(list interface{}, target interface{}) bool {
		listValue := reflect.ValueOf(list)
		if listValue.Kind() != reflect.Slice {
			return false
		}
		targetType := reflect.TypeOf(target)
		targetValue := reflect.ValueOf(target)
		for i := 0; i < listValue.Len(); i++ {
			item := listValue.Index(i).Interface()
			itemType := reflect.TypeOf(item)
			if !targetType.ConvertibleTo(itemType) {
				continue
			}
			t := targetValue.Convert(itemType).Interface()
			if ok := reflect.DeepEqual(item, t); ok {
				return true
			}
		}
		return false
	}

# Expect file permissions to be 0600, 0750
# G301: Poor file permissions used when creating a directory
# G302: Poor file permissions used with chmod
# G306: Poor file permissions used when writing to a new file
snippet	ignore_goseccc
	//#nosec G301 G302 G306
snippet	ignore_golangcilinttt
	//nolint:gosec,errcheck,revive,stylecheck,staticcheck,unused,gosimple,misspell,prealloc,scopelint,unconvert
snippet	ignore_staticcheckkk
	//lint:ignore <チェックID> <理由（必須）>

snippet	deep_copyyy
	func DeepCopy(src interface{}, dst interface{}) (err error) {
		b, err := json.Marshal(src)
		if err != nil {
				return err
		}
		err = json.Unmarshal(b, dst)
		if err != nil {
				return err
		}
		return nil
	}

snippet	count_field
	reflect.TypeOf(Person{}).NumField()

snippet	for_each_field
	v := reflect.ValueOf($1)
	t := v.Type()
	for i := 0; i< v.NumField(); i++ {
			fmt.Printf("Field: %s\tValue: %v\n", t.Field(i).Name, v.Field(i).Interface())
	}

#snippet	stdinnn
#	stdin := os.Stdin
#	stat, err := stdin.Stat()
#	if err != nil {
#		return err
#	}
#	#if stat.Size() == 0 {
#	#	return fmt.Errorf("stdin is empty")
#	#}
#	scanner := bufio.NewScanner(os.Stdin)
#	for scanner.Scan() {
#		fmt.Println(scanner.Text())
#	}

snippet	stdinnn
snippet	pipe_or_nottt
	fm, err := os.Stdin.Stat()
	if err != nil {
		return err
	}
	if (fm.Mode() & os.ModeCharDevice) != 0 {
		return fmt.Errorf("no stdin")
	}
	// pipe (if stdin is not charactor device(like keyboard, etc))
	scanner := bufio.NewScanner(os.Stdin)
	for scanner.Scan() {
		fmt.Println(scanner.Text())
	}

snippet loop_stucttt
	p := Person{
			Name:    "John",
			Age:     30,
			Address: "Tokyo",
	}
	// Age フィールドを更新する
	pValue := reflect.ValueOf(&p).Elem()
	ageField := pValue.FieldByName("Age")
	ageField.SetInt(35)
	// Personのフィールドをループで処理する
	valueType := reflect.ValueOf(p)
	valueTypeElem := valueType.Type()
	for i := 0; i < valueType.NumField(); i++ {
			field := valueType.Field(i)
			fieldName := valueTypeElem.Field(i).Name
			fieldValue := field.Interface()
			fmt.Printf("%s: %v\n", fieldName, fieldValue)
	}

snippet merge_mappp
	func mergeMap(map1, map2 map[string]interface{}) (map[string]interface{}, error) {
		var err error
		for key, val := range map2 {
			switch val.(type) {
			case map[string]interface{}:
				if _, ok := map1[key]; !ok {
					map1[key] = val
				} else {
					map1[key], err = mergeMap(map1[key].(map[string]interface{}), val.(map[string]interface{}))
					if err != nil {
						return nil, err
					}
				}
			default:
				map1[key] = val
			}
		}
		return map1, err
	}

snippet	to_lowerrr
	strings.ToLower($1)
snippet	to_upperrr
	strings.ToUpper($1)

snippet cast_structtt
	type Common struct {
		Gender int
		From   string
		To     string
	}
	type Foo struct {
		Id    string
		Name  string
		Extra Common
	}
	type Bar struct {
		Id    string
		Name  string
		Extra Common
	}
	foo := Foo{Id: "123", Name: "Joe"}
	bar := Bar(foo)
	fmt.Println(bar)

snippet cast_pointerrr
	package main
	type mypint *int
	func set(a *mypint) {
			i := int(5)
			*a = &i
	}
	func main() {
			var k *int
			set((*mypint)(&k))
			print(*k)
	}
	// or
	package main
	type myint int
	func set(a *myint) *myint {
			i := myint(5)
			a = &i
			return a
	}
	func main() {
			var k *int
			k = (*int)(set((*myint)(k)))
			print(*k)
	}

snippet cast_anyyy
alias cast_interfaceee
	v, ok = i.(T)

# From Go 1.0
# Go1.10まではNamed typeと呼ばれていたが、Go1.11から言語仕様上はDefined typeと呼ばれるようになった。
# 別の型なので明示的にキャストしないと互換性がない
# 新しいメソッドを追加できる
# Defined typeはプリミティブな型に対しても利用することができる。
# Defined typeで宣言した新しい型と元になった型には互換性がないため、Value Object的に利用することができる。
snippet defined_typeeee
	type Name string
# From Go 1.9
# キャストせずに同じ型として利用できる
# エイリアスに新しいメソッドは定義できない。
snippet type_aliasss
	type Name = string

# [...] は Go の配列リテラルの書き方で、配列の要素数を省略すると要素数が自動で決まる固定長配列
# slices.Contains はスライスのみ対応しているため、配列を渡す場合はスライスに変換する必要がある
# 固定スライスをスライスに変換する場合は [:] を使う
# [[golang] Go言語は、map、slice、arrayは定数化出来ない仕様。では代用策は？ #Go - Qiita](https://qiita.com/rikimaru-odd-person/items/4b460e14a6dfc738ca97):w
snippet change_const_to_slice
	var values = [...]string{"sample"}
	slices.Contains(values[:], "sample")

snippet mainnn
	package main
	import (
		"fmt"
		"log"
		"log/slog"
		"os"
		"regexp"
		"github.com/efficientgo/core/errors"
	)
	func sub() error {
		targetDir := "./keep"
		files, err := os.ReadDir(targetDir)
		if err != nil {
			return errors.Wrapf(err, "Failed to readDir. %s", slog.String("dir", targetDir))
		}
		r := regexp.MustCompile(\`.*json\`)
		for _, f := range files {
			name := f.Name()
			if !r.MatchString(name) {
				continue
			}
			log.Println("==> ", name, f)
		}
		// glob ./keep/*json files
		return nil
	}
	func main() {
		err := sub()
		if err != nil {
			fmt.Printf("Error: %+v", err)
		}
	}

snippet dump_request_responseee
	func DumpRequest(req *http.Request, prefix string) {
		if prefix != "" {
			prefix += " "
		}
		_log := func(format string, args ...interface{}) {
			slog.Info(fmt.Sprintf(prefix+format, args...))
		}
		if req == nil {
			_log("Request is nil")
			return
		}
		_log("Request")
		_log("  URL: %s", req.URL)
		_log("  Method: %s", req.Method)
		_log("  Body: %s", func() string {
			if req.Body == nil {
				return "nil"
			}
			body, err := io.ReadAll(req.Body)
			if err != nil {
				return fmt.Sprintf("Failed to read body: %s", err)
			}
			// 一度読んだら読めなくなるので、戻す
			req.Body = io.NopCloser(bytes.NewBuffer(body))
			return string(body)
		}())
	}

	func DumpResponse(code int, b []byte, prefix string) {
		if prefix != "" {
			prefix += " "
		}
		_log := func(format string, args ...interface{}) {
			slog.Info(fmt.Sprintf(prefix+format, args...))
		}
		_log("Response")
		_log("  %d: %+v", code, string(b))
	}

snippet efficientgo_errors
alias errors_import_efficientgo
	"github.com/efficientgo/core/errors"

snippet gen_passworddd
	func GeneratePassword() string {
		length := 12
		chars := "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()_+"
		result := make([]byte, length)

		for i := range result {
			// crypto/randとmath/bigを使用して均一な分布のランダムインデックスを生成
			n, err := rand.Int(rand.Reader, big.NewInt(int64(len(chars))))
			if err != nil {
				slog.Error("Failed to generate crypto random", "error", err)
				continue
			}
			result[i] = chars[n.Int64()]
		}
		return string(result)
	}

snippet defer_closeee
	defer resp.Body.Close() //nolint:errcheck

snippet tsvvv
	w := csv.NewWriter(os.Stdout)
	w.Comma = '\t' // タブ区切りに設定
	w.Write([]string{"foo", "bar", "baz"})
	w.Flush()
	if err := w.Error(); err != nil {
		// エラーハンドリング
	}

snippet externalll
	package external

	import (
		"bytes"
		"encoding/json"
		"errors"
		"fmt"
		"io"
		"log"
		"net"
		"net/http"
		"os"
		"strings"
		"time"
	)

	const (
		APITimeout = 30 * time.Second
		prefix     = "==> [APIClient]"
	)

	type APIHandler interface {
		Do(req *http.Request, opts ...RequestOption) ([]byte, int, error)
	}

	var _ APIHandler = (*APIClient)(nil)

	type APIClient struct {
		Client *http.Client
	}

	// RequestOption applies a modification to an http.Request before it is sent.
	type RequestOption func(req *http.Request)

	// Authorizationヘッダ名の定数
	const defaultAuthorizationHeader = "Authorization"

	// WithHeader returns a RequestOption that sets a custom header.
	func WithHeader(key, value string) RequestOption {
		return func(req *http.Request) {
			if key != "" && value != "" {
				req.Header.Set(key, value)
			}
		}
	}

	// WithAuthorization returns a RequestOption that sets the Authorization header.
	func WithAuthorization(value string) RequestOption {
		return WithHeader(defaultAuthorizationHeader, value)
	}

	// WithAuthorizationBearer returns a RequestOption that sets the Authorization header with a Bearer token.
	func WithAuthorizationBearer(token string) RequestOption {
		return WithHeader(defaultAuthorizationHeader, "Bearer "+token)
	}

	func NewAPIClient() *APIClient {
		return &APIClient{
			Client: &http.Client{
				Timeout: (APITimeout),
			},
		}
	}

	func (c *APIClient) Do(req *http.Request, opts ...RequestOption) ([]byte, int, error) {
		// Option適用
		for _, opt := range opts {
			opt(req)
		}

		if isDebug() {
			c.DumpRequest(req, prefix)
		}

		res, err := c.Client.Do(req)
		if err != nil {
			var ne net.Error
			if ok := errors.As(err, &ne); ok {
				return nil, http.StatusRequestTimeout, err
			}

			return nil, http.StatusInternalServerError, err
		}
		defer func() {
			if err := res.Body.Close(); err != nil {
				log.Printf("Failed to close response body: %v", err)
			}
		}()

		body, err := io.ReadAll(res.Body)
		if err != nil {
			return nil, http.StatusInternalServerError, err
		}
		if isDebug() {
			c.DumpResponse(res.StatusCode, body, prefix)
		}

		return body, res.StatusCode, nil
	}

	func isDebug() bool {
		return os.Getenv("DEBUG_EXT_HTTP_CLIENT") == "true"
	}

	func isDebugPretty() bool {
		return os.Getenv("DEBUG_EXT_HTTP_CLIENT_PRETTY") == "true"
	}

	func (c *APIClient) DumpRequest(req *http.Request, prefix string) {
		if prefix != "" {
			prefix += " "
		}
		if req == nil {
			// slog.Info(prefix + "Request is nil")
			log.Printf("%sRequest is nil", prefix)
			return
		}

		// // ヘッダをダンプ
		// for k, v := range req.Header {
		// 	log.Printf("%sRequest  >>> Header: %s: %v", prefix, k, v)
		// }
		log.Println(prefix+"Request  >>>", "URL", req.URL.String(), "Method", req.Method, "body", func() string {
			if req.Body == nil {
				return "(empty)"
			}
			body, err := io.ReadAll(req.Body)
			if err != nil {
				return fmt.Sprintf("Failed to read body: %s", err)
			}
			// 一度読んだら読めなくなるので、戻す
			req.Body = io.NopCloser(bytes.NewBuffer(body))
			return c.humanReadableBody(body)
		}())
	}

	func (c *APIClient) DumpResponse(code int, b []byte, prefix string) {
		if prefix != "" {
			prefix += " "
		}
		log.Printf("%sResponse <<< code: %d, body:%s", prefix, code, c.humanReadableBody(b))
	}

	func (c *APIClient) humanReadableBody(b []byte) string {
		bodyStr := string(b)
		if len(bodyStr) == 0 {
			return "(empty)"
		}
		if !isDebugPretty() {
			return bodyStr
		}
		tab := "  "
		var js any
		if json.Unmarshal(b, &js) == nil {
			// JSONであればインデント付きで出力
			pretty, err := json.MarshalIndent(js, "", tab)
			if err == nil {
				return "\n" + string(pretty)
			}
		}
		// JSONでなければ従来通り
		readableBody := "\n" + tab + bodyStr
		readableBody = strings.ReplaceAll(readableBody, "\n", "\n"+tab)
		readableBody = strings.ReplaceAll(readableBody, "\r", "")
		readableBody = strings.ReplaceAll(readableBody, "\t", tab)
		return readableBody
	}
snippet external_testtt
	package external

	import (
		"bytes"
		"errors"
		"io"
		"log"
		"net"
		"net/http"
		"net/http/httptest"
		"net/url"
		"testing"
		"time"

		"github.com/stretchr/testify/assert"
		"github.com/stretchr/testify/require"
	)

	func WriteJSONStringUtil(w http.ResponseWriter, data string) {
		_, _ = w.Write([]byte(data))
	}

	func TestNewAPIClient(t *testing.T) {
		client := NewAPIClient()

		assert.NotNil(t, client)
		assert.NotNil(t, client.Client)
		assert.Equal(t, APITimeout, client.Client.Timeout)
	}

	func TestWithAuthorization(t *testing.T) {
		tests := []struct {
			name       string
			authValue  string
			wantHeader string
		}{
			{
				name:       "with auth token",
				authValue:  "Bearer test-token",
				wantHeader: "Bearer test-token",
			},
			{
				name:       "empty auth value",
				authValue:  "",
				wantHeader: "",
			},
		}

		for _, tt := range tests {
			t.Run(tt.name, func(t *testing.T) {
				req := httptest.NewRequest(http.MethodGet, "http://example.com", nil)

				opt := WithAuthorization(tt.authValue)
				opt(req)

				if tt.wantHeader == "" {
					assert.Empty(t, req.Header.Get(defaultAuthorizationHeader))
				} else {
					assert.Equal(t, tt.wantHeader, req.Header.Get(defaultAuthorizationHeader))
				}
			})
		}
	}

	func TestAPIClient_Request(t *testing.T) {
		tests := []struct {
			name           string
			setupServer    func() *httptest.Server
			setupRequest   func() *http.Request
			opts           []RequestOption
			wantBody       []byte
			wantStatusCode int
			wantErr        bool
		}{
			{
				name: "successful GET request",
				setupServer: func() *httptest.Server {
					return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
						w.WriteHeader(http.StatusOK)
						WriteJSONStringUtil(w, \`{"status":"ok"}\`)
					}))
				},
				setupRequest: func() *http.Request {
					req, _ := http.NewRequest(http.MethodGet, "", nil)
					return req
				},
				wantBody:       []byte(\`{"status":"ok"}\`),
				wantStatusCode: http.StatusOK,
				wantErr:        false,
			},
			{
				name: "request with authorization header",
				setupServer: func() *httptest.Server {
					return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
						assert.Equal(t, "Bearer test-token", r.Header.Get("Authorization"))
						w.WriteHeader(http.StatusOK)
						WriteJSONStringUtil(w, \`{"authenticated":true}\`)
					}))
				},
				setupRequest: func() *http.Request {
					req, _ := http.NewRequest(http.MethodGet, "", nil)
					return req
				},
				opts:           []RequestOption{WithAuthorization("Bearer test-token")},
				wantBody:       []byte(\`{"authenticated":true}\`),
				wantStatusCode: http.StatusOK,
				wantErr:        false,
			},
			{
				name: "server returns error status",
				setupServer: func() *httptest.Server {
					return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
						w.WriteHeader(http.StatusInternalServerError)
						WriteJSONStringUtil(w, \`{"error":"internal server error"}\`)
					}))
				},
				setupRequest: func() *http.Request {
					req, _ := http.NewRequest(http.MethodGet, "", nil)
					return req
				},
				wantBody:       []byte(\`{"error":"internal server error"}\`),
				wantStatusCode: http.StatusInternalServerError,
				wantErr:        false,
			},
			{
				name: "POST request with body",
				setupServer: func() *httptest.Server {
					return httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
						body, _ := io.ReadAll(r.Body)
						assert.Equal(t, \`{"name":"test"}\`, string(body))
						w.WriteHeader(http.StatusCreated)
						WriteJSONStringUtil(w, \`{"id":123}\`)
					}))
				},
				setupRequest: func() *http.Request {
					req, _ := http.NewRequest(http.MethodPost, "", bytes.NewBufferString(\`{"name":"test"}\`))
					return req
				},
				wantBody:       []byte(\`{"id":123}\`),
				wantStatusCode: http.StatusCreated,
				wantErr:        false,
			},
		}

		for _, tt := range tests {
			t.Run(tt.name, func(t *testing.T) {
				server := tt.setupServer()
				defer server.Close()

				client := NewAPIClient()
				req := tt.setupRequest()
				parsedServerURL, err := url.Parse(server.URL)
				if err != nil {
					t.Fatalf("Failed to parse server URL: %v", err)
				}
				req.URL.Scheme = parsedServerURL.Scheme
				req.URL.Host = parsedServerURL.Host

				body, statusCode, err := client.Do(req, tt.opts...)

				if tt.wantErr {
					assert.Error(t, err)
				} else {
					assert.NoError(t, err)
					assert.Equal(t, tt.wantBody, body)
					assert.Equal(t, tt.wantStatusCode, statusCode)
				}
			})
		}
	}

	func TestAPIClient_Request_NetworkError(t *testing.T) {
		client := NewAPIClient()
		client.Client.Timeout = 1 * time.Millisecond

		// Create a server that sleeps longer than timeout
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			time.Sleep(10 * time.Millisecond)
			w.WriteHeader(http.StatusOK)
		}))
		defer server.Close()

		req, _ := http.NewRequest(http.MethodGet, server.URL, nil)

		body, statusCode, err := client.Do(req)

		assert.Error(t, err)
		assert.Nil(t, body)
		assert.Equal(t, http.StatusRequestTimeout, statusCode)

		// Check if it's a network timeout error
		var netErr net.Error
		assert.True(t, errors.As(err, &netErr))
	}

	func TestAPIClient_Request_InvalidURL(t *testing.T) {
		client := NewAPIClient()
		client.Client.Timeout = 1 * time.Second // Short timeout
		req, _ := http.NewRequest(http.MethodGet, "http://invalid-domain-that-does-not-exist-12345.com", nil)

		body, statusCode, err := client.Do(req)

		assert.Error(t, err)
		assert.Nil(t, body)
		// Network errors may return different status codes
		assert.Contains(t, []int{http.StatusRequestTimeout, http.StatusInternalServerError}, statusCode)
	}

	func TestAPIClient_DumpRequest(t *testing.T) {
		client := NewAPIClient()

		// Set environment for pretty printing
		t.Setenv("DEBUG_EXT_HTTP_CLIENT_PRETTY", "true")

		tests := []struct {
			name       string
			req        *http.Request
			prefix     string
			wantOutput []string
		}{
			{
				name:       "nil request",
				req:        nil,
				prefix:     "[TEST]",
				wantOutput: []string{"[TEST] Request is nil"},
			},
			{
				name: "GET request without body",
				req: func() *http.Request {
					req, _ := http.NewRequest(http.MethodGet, "http://example.com/test", nil)
					return req
				}(),
				prefix:     "[TEST]",
				wantOutput: []string{"[TEST] Request  >>>", "URL http://example.com/test", "Method GET", "body (empty)"},
			},
			{
				name: "POST request with body",
				req: func() *http.Request {
					req, _ := http.NewRequest(http.MethodPost, "http://example.com/test", bytes.NewBufferString(\`{"key":"value"}\`))
					return req
				}(),
				prefix:     "[TEST]",
				wantOutput: []string{"[TEST] Request  >>>", "URL http://example.com/test", "Method POST", "body", "\"key\": \"value\""},
			},
		}

		for _, tt := range tests {
			t.Run(tt.name, func(t *testing.T) {
				// Capture log output in a buffer
				var buf bytes.Buffer
				origLogger := log.Writer()
				log.SetOutput(&buf)
				defer log.SetOutput(origLogger)

				client.DumpRequest(tt.req, tt.prefix)

				output := buf.String()
				for _, want := range tt.wantOutput {
					assert.Contains(t, output, want)
				}
			})
		}
	}

	func TestAPIClient_DumpResponse(t *testing.T) {
		client := NewAPIClient()

		// Set environment for pretty printing
		t.Setenv("DEBUG_EXT_HTTP_CLIENT_PRETTY", "true")

		tests := []struct {
			name       string
			code       int
			body       []byte
			prefix     string
			wantOutput []string
		}{
			{
				name:       "successful response",
				code:       200,
				body:       []byte(\`{"status":"ok"}\`),
				prefix:     "[TEST]",
				wantOutput: []string{"[TEST] Response <<<", "code: 200", "body:", "\"status\": \"ok\""},
			},
			{
				name:       "empty response body",
				code:       204,
				body:       []byte{},
				prefix:     "[TEST]",
				wantOutput: []string{"[TEST] Response <<<", "code: 204", "body:(empty)"},
			},
			{
				name:       "error response",
				code:       500,
				body:       []byte(\`{"error":"internal server error"}\`),
				prefix:     "",
				wantOutput: []string{"Response <<<", "code: 500", "body:", "\"error\": \"internal server error\""},
			},
		}

		for _, tt := range tests {
			t.Run(tt.name, func(t *testing.T) {
				// Capture log output in a buffer
				var buf bytes.Buffer
				origLogger := log.Writer()
				log.SetOutput(&buf)
				defer log.SetOutput(origLogger)

				client.DumpResponse(tt.code, tt.body, tt.prefix)

				output := buf.String()
				for _, want := range tt.wantOutput {
					assert.Contains(t, output, want)
				}
			})
		}
	}

	func TestAPIClient_humanReadableBody(t *testing.T) {
		client := NewAPIClient()

		tests := []struct {
			name  string
			input []byte
			want  string
			env   map[string]string
		}{
			{
				name:  "empty body",
				input: []byte{},
				want:  "(empty)",
			},
			{
				name:  "plain text body",
				input: []byte("Hello, World!"),
				want:  "\n    Hello, World!",
				env:   map[string]string{"DEBUG_EXT_HTTP_CLIENT_PRETTY": "true"},
			},
			{
				name:  "JSON body without pretty print",
				input: []byte(\`{"key":"value","number":123}\`),
				want:  \`{"key":"value","number":123}\`,
				env:   map[string]string{"DEBUG_EXT_HTTP_CLIENT_PRETTY": "false"},
			},
			{
				name:  "JSON body with pretty print",
				input: []byte(\`{"key":"value","number":123}\`),
				want:  "\n{\n  \"key\": \"value\",\n  \"number\": 123\n}",
				env:   map[string]string{"DEBUG_EXT_HTTP_CLIENT_PRETTY": "true"},
			},
			{
				name:  "invalid JSON with pretty print enabled",
				input: []byte(\`not a json\`),
				want:  "\n    not a json",
				env:   map[string]string{"DEBUG_EXT_HTTP_CLIENT_PRETTY": "true"},
			},
			{
				name:  "text with newlines and tabs",
				input: []byte("line1\nline2\tindented"),
				want:  "\n    line1\n  line2  indented",
				env:   map[string]string{"DEBUG_EXT_HTTP_CLIENT_PRETTY": "true"},
			},
		}

		for _, tt := range tests {
			t.Run(tt.name, func(t *testing.T) {
				for k, v := range tt.env {
					t.Setenv(k, v)
				}

				result := client.humanReadableBody(tt.input)
				assert.Equal(t, tt.want, result)
			})
		}
	}

	func TestIsDebug(t *testing.T) {
		tests := []struct {
			name     string
			envValue string
			want     bool
		}{
			{
				name:     "debug enabled",
				envValue: "true",
				want:     true,
			},
			{
				name:     "debug disabled",
				envValue: "false",
				want:     false,
			},
			{
				name:     "debug not set",
				envValue: "",
				want:     false,
			},
		}

		for _, tt := range tests {
			t.Run(tt.name, func(t *testing.T) {
				t.Setenv("DEBUG_EXT_HTTP_CLIENT", tt.envValue)

				assert.Equal(t, tt.want, isDebug())
			})
		}
	}

	func TestIsDebugPretty(t *testing.T) {
		tests := []struct {
			name     string
			envValue string
			want     bool
		}{
			{
				name:     "pretty debug enabled",
				envValue: "true",
				want:     true,
			},
			{
				name:     "pretty debug disabled",
				envValue: "false",
				want:     false,
			},
			{
				name:     "pretty debug not set",
				envValue: "",
				want:     false,
			},
		}

		for _, tt := range tests {
			t.Run(tt.name, func(t *testing.T) {
				t.Setenv("DEBUG_EXT_HTTP_CLIENT_PRETTY", tt.envValue)

				assert.Equal(t, tt.want, isDebugPretty())
			})
		}
	}

	func TestAPIClient_Request_WithDebugEnabled(t *testing.T) {
		t.Setenv("DEBUG_EXT_HTTP_CLIENT", "true")

		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.WriteHeader(http.StatusOK)
			WriteJSONStringUtil(w, \`{"debug":"enabled"}\`)
		}))
		defer server.Close()

		client := NewAPIClient()
		req, err := http.NewRequest(http.MethodGet, server.URL, nil)
		require.NoError(t, err)

		// Capture log output in a buffer
		var buf bytes.Buffer
		origLogger := log.Writer()
		log.SetOutput(&buf)
		defer log.SetOutput(origLogger)

		body, statusCode, err := client.Do(req)

		// Verify request was successful
		assert.NoError(t, err)
		assert.Equal(t, http.StatusOK, statusCode)
		assert.Equal(t, []byte(\`{"debug":"enabled"}\`), body)

		// Verify debug output was generated
		debugOutput := buf.String()
		assert.Contains(t, debugOutput, "[APIClient] Request  >>>")
		assert.Contains(t, debugOutput, "[APIClient] Response <<<")
	}

	// errorReader simulates an io.Reader that always returns an error
	type errorReader struct{}

	func (e errorReader) Read([]byte) (int, error) {
		return 0, errors.New("read error")
	}

	func (e errorReader) Close() error {
		return nil
	}

	func TestAPIClient_Request_ReadAllError(t *testing.T) {
		server := httptest.NewServer(http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			w.WriteHeader(http.StatusOK)
			// The response body will be replaced with an error reader in the test
		}))
		defer server.Close()

		client := NewAPIClient()

		// Create a custom transport that returns a response with an errorReader
		client.Client.Transport = &errorTransport{originalURL: server.URL}

		req, err := http.NewRequest(http.MethodGet, server.URL, nil)
		require.NoError(t, err)

		body, statusCode, err := client.Do(req)

		// Should return error from ReadAll
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "read error")
		assert.Equal(t, http.StatusInternalServerError, statusCode)
		assert.Nil(t, body)
	}

	// errorTransport is a custom transport that returns responses with errorReader bodies
	type errorTransport struct {
		originalURL string
	}

	func (et *errorTransport) RoundTrip(req *http.Request) (*http.Response, error) {
		return &http.Response{
			StatusCode: http.StatusOK,
			Header:     make(http.Header),
			Body:       errorReader{},
			Request:    req,
		}, nil
	}

	func TestAPIClient_DumpRequest_ReadBodyError(t *testing.T) {
		client := NewAPIClient()

		// Create a request with an errorReader body
		req, err := http.NewRequest(http.MethodPost, "http://example.com", errorReader{})
		require.NoError(t, err)

		// Capture log output
		var buf bytes.Buffer
		origLogger := log.Writer()
		log.SetOutput(&buf)
		defer log.SetOutput(origLogger)

		// Call DumpRequest which should handle the read error gracefully
		client.DumpRequest(req, "TEST")

		// Verify that the error is handled and logged
		logOutput := buf.String()
		assert.Contains(t, logOutput, "TEST Request  >>>")
		assert.Contains(t, logOutput, "Failed to read body: read error")
	}

	func TestAPIClient_DumpRequest_NilRequest(t *testing.T) {
		client := NewAPIClient()

		// Capture log output
		var buf bytes.Buffer
		origLogger := log.Writer()
		log.SetOutput(&buf)
		defer log.SetOutput(origLogger)

		// Call DumpRequest with nil request
		client.DumpRequest(nil, "TEST")

		// Verify that nil request is handled
		logOutput := buf.String()
		assert.Contains(t, logOutput, "TEST Request is nil")
	}
