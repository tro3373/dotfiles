##############################################
# Alias
##############################################
alias vi=vim
case "${OSTYPE}" in
    # for MAC-OS
    darwin*)
        alias ls="ls -G -w"
        alias xcode='open -a Xcode'         # コマンドラインからXcode起動
        alias gvim='open -a MacVim'         # コマンドラインからMacVim起動

        fnd() {                             # 指定ディレクトリをFinderで開く
            if [ $# = 0 ]; then
                open `pwd`
            else
                for arg in $@; do
                    if [ -d ${arg} ]; then
                        open ${arg}
                    else
                        open -R ${arg}
                    fi
                done
            fi
        }
        ;;

    # for Linux
    linux*)
        alias ls="ls --color"
        alias nt=nautilus                               # 指定ディレクトリをnautilusで開く
        alias open=nautilus                             # 指定ディレクトリをnautilusで開く
        $ gv() {gvim -f $1 &!}                          # コマンドラインからgVim起動
        alias pbcopy='xsel --clipboard --input'         # Mac OS-Xのpbcopyの代わり
        alias pbpaste='xsel --clipboard --output'       # Mac OS-Xのpbpasteの代わり
        alias tmux-copy='tmux save-buffer - | pbcopy'   # tmuxのコピーバッファとクリップボードを連携
        alias tmux='tmux -2'                            # Ubuntu12.04で256を使用するため
        alias git='nocorrect git'                       # Ubuntuで_gitと誤解されるため
        ;;

    #for FreeBSD
    freebsd*)
        alias ls="ls -G -w"
        ;;

    #cygwin
    cygwin*)
        alias open='cygstart'                           # 指定ディレクトリをwindowエクスプローラで開く
        alias apt-get='apt-cyg'                         # apt-get emulate
        alias tmux='tmux -2'                            # 256Color有効化
        alias sudo='echo "No sudo...";'                 # sudo がないので、エイリアスで逃げる
esac

alias la="ls -a"
alias lf="ls -F"
alias l="ls -l"
alias ll="ls -la"
alias lla="ls -la"
alias du="du -h"
alias df="df -h"
alias su="su -l"
alias grep='grep --color=auto'
alias fgrep='fgrep --color=auto'
alias egrep='egrep --color=auto'
alias pod='nocorrect pod'
alias where="command -v"
alias diff="diff -Nru"
#alias j="jobs -l"
if type gomi > /dev/null 2>&1; then
    alias gm="gomi"
fi

##############################################
# functions
##############################################

#
# "up"コマンドは、ディレクトリ階層を非常に簡単に上れるようにする為のコマンドです。
# "up"コマンドを単体で利用した場合、「cd ../」コマンドと同一です。
# "up 2"のように、引数に数値を与えて実行した場合、その階層分だけ上に移動する事ができます。
# By https://github.com/m-yamashita/up
#
function up(){
    cpath=./
    for i in `seq 1 1 $1`; do
        cpath=$cpath../
    done
    cd $cpath
}

#
# プロセスのkill
# By http://k0kubun.hatenablog.com/entry/2014/07/06/033336
#
function peco-pkill() {
    for pid in `ps aux | peco | awk '{ print $2 }'`; do
        kill $pid
        echo "Killed ${pid}"
    done
}
alias pk="peco-pkill"

#
# historyからの絞り込み実行
# By http://k0kubun.hatenablog.com/entry/2014/07/06/033336
#
function peco-select-history() {
    typeset tac
    if which tac > /dev/null; then
        tac=tac
    else
        tac='tail -r'
    fi
    BUFFER=$(fc -l -n 1 | eval $tac | peco --query "$LBUFFER")
    CURSOR=$#BUFFER
    zle redisplay
}
zle -N peco-select-history
bindkey '^r' peco-select-history

#
# 検索してCD
#
function peco-findcd() {
    # 何階層下までリスティングするか
    local depth="5"
    # .で始まるディレクトリは除外
    local selected_dir="$(find . -maxdepth ${depth} -type d ! -path "*/.*" 2>/dev/null | peco)"
    if [ -d "$selected_dir" ]; then
        BUFFER="cd \"${selected_dir}\""
        CURSOR=$#BUFFER
        zle accept-line
    fi
    zle clear-screen
 }
zle -N peco-findcd
bindkey '^k' peco-findcd

#
# Find した結果見つかったファイルをVimで開く
#
function peco_findvim() {
    # 何階層下までリスティングするか
    local depth="5"
    # .で始まるディレクトリは除外
#    local file="$(find . -maxdepth ${depth} -type f ! -path "*/.*" 2>/dev/null | peco)"
#    [ ! "$file" = "" ] && vim "$file"
    BUFFER=$(find . -maxdepth ${depth} -type f ! -path "*/.*" 2>/dev/null | peco --query "$LBUFFER")
    CURSOR=$#BUFFER
    zle redisplay
 }
zle -N peco_findvim
bindkey '^g' peco_findvim

#
# 'cd ..' する
#
function cd_up() {
    cd ..
    zle reset-prompt
}
zle -N cd_up
bindkey '^f' vi-kill-line # デフォルトのキーバインド(^U)を変更
bindkey '^u' cd_up


#
#
#
bd () {
  (($#<1)) && {
    print -- "usage: $0 <name-of-any-parent-directory>"
    return 1
  } >&2
  # Get parents (in reverse order)
  local parents
  local num=${#${(ps:/:)${PWD}}}
  local i
  for i in {$((num+1))..2}
  do
    parents=($parents "$(echo $PWD | cut -d'/' -f$i)")
  done
  parents=($parents "/")
  # Build dest and 'cd' to it
  local dest="./"
  local parent
  foreach parent (${parents})
  do
    if [[ $1 == $parent ]]
    then
      cd $dest
      return 0
    fi
    dest+="../"
  done
  print -- "bd: Error: No parent directory named '$1'"
  return 1
}
_bd () {
  # Get parents (in reverse order)
  local num=${#${(ps:/:)${PWD}}}
  local i
  for i in {$((num+1))..2}
  do
    reply=($reply "`echo $PWD | cut -d'/' -f$i`")
  done
  reply=($reply "/")
}
compctl -V directories -K _bd bd

#
# Markdown 検索
#
function find_vim_markdown() {
    local markdown_dir="$HOME/md"
    if [ ! -e "$markdown_dir" ]; then
        return
    fi
    local file="$(find ~/md -name "*.md" 2>/dev/null | peco)"
    [ ! "$file" = "" ] && vim "$file"
}
alias fvm="find_vim_markdown"


#
# SVN 変更一覧表示
#
function svndifflist() {
    svn diff | awk '/^Index/ {print $NF}'
}
alias svndl="svndifflist"

#
# ssh 時のWindow名を元に戻す
#
#function ssh() {
#    local window_name=$(tmux display -p '#{window_name}')
#    command ssh $@
#    tmux rename-window $window_name
#}

#
# agした結果をpecoで選択してvimで開く
#
function agvim () {
  vim $(ag "$@" | peco --query "$LBUFFER" | awk -F : '{print "-c " $2 " " $1}')
}

#
# history
#
function hisall () { history -E 1 }

#
# Git Diff Alias
#
function gdiff() {
    local DIFF
    if type -p git >/dev/null 2>&1; then
        DIFF="git diff --no-index --binary"
    else
        DIFF="diff -u"
    fi
    if [[ $# -eq 1 ]]; then
        $DIFF "$1~" "$1"
    else
        $DIFF "$@"
    fi
}

#
# fshow - git commit browser
#
fshow() {
  local out sha q
  while out=$(
      git log --graph --color=always \
          --format="%C(auto)%h%d %s %C(black)%C(bold)%cr" "$@" |
      fzf --ansi --multi --no-sort --reverse --query="$q" --print-query); do
    q=$(head -1 <<< "$out")
    while read sha; do
      git show --color=always $sha | less -R
    done < <(sed '1d;s/^[^a-z0-9]*//;/^$/d' <<< "$out" | awk '{print $1}')
  done
}

#
# available check
#
export FILTER="fzf:peco"
available () {
    local x candidates
    candidates="$1:"
    while [ -n "$candidates" ]
    do
        x=${candidates%%:*}
        candidates=${candidates#*:}
        if type "$x" >/dev/null 2>&1; then
            echo "$x"
            return 0
        else
            continue
        fi
    done
    return 1
}
available $FILTER

#
# tmux start settings
#
function is_exists() { type "$1" >/dev/null 2>&1; return $?; }
function is_osx() { [[ $OSTYPE == darwin* ]]; }
function is_screen_running() { [ ! -z "$STY" ]; }
function is_tmux_runnning() { [ ! -z "$TMUX" ]; }
function is_screen_or_tmux_running() { is_screen_running || is_tmux_runnning; }
function shell_has_started_interactively() { [ ! -z "$PS1" ]; }
function is_ssh_running() { [ ! -z "$SSH_CONECTION" ]; }

function tmux_automatically_attach_session()
{
    if is_screen_or_tmux_running; then
        ! is_exists 'tmux' && return 1

        if is_tmux_runnning; then
            echo "${fg_bold[red]} --< TMUX >-- ${reset_color}" >/dev/null 2>&1
#            echo "${fg_bold[red]} _____ __  __ _   ___  __ ${reset_color}"
#            echo "${fg_bold[red]}|_   _|  \/  | | | \ \/ / ${reset_color}"
#            echo "${fg_bold[red]}  | | | |\/| | | | |\  /  ${reset_color}"
#            echo "${fg_bold[red]}  | | | |  | | |_| |/  \  ${reset_color}"
#            echo "${fg_bold[red]}  |_| |_|  |_|\___//_/\_\ ${reset_color}"
        elif is_screen_running; then
            echo "This is on screen."
        fi
    else
        if shell_has_started_interactively && ! is_ssh_running; then
            if ! is_exists 'tmux'; then
                echo 'Error: tmux command not found' 2>&1
                return 1
            fi

            if tmux has-session >/dev/null 2>&1 && tmux list-sessions | grep -qE '.*]$'; then
                # detached session exists
                tmux list-sessions
                echo -n "Tmux: attach? (y/N/num) "
                read
                if [[ "$REPLY" =~ ^[Yy]$ ]] || [[ "$REPLY" == '' ]]; then
                    tmux attach-session
                    if [ $? -eq 0 ]; then
                        echo "$(tmux -V) attached session"
                        return 0
                    fi
                elif [[ "$REPLY" =~ ^[0-9]+$ ]]; then
                    tmux attach -t "$REPLY"
                    if [ $? -eq 0 ]; then
                        echo "$(tmux -V) attached session"
                        return 0
                    fi
                fi
            fi

            if is_osx && is_exists 'reattach-to-user-namespace'; then
                # on OS X force tmux's default command
                # to spawn a shell in the user's namespace
                tmux_config=$(cat $HOME/.tmux.conf <(echo 'set-option -g default-command "reattach-to-user-namespace -l $SHELL"'))
                tmux -f <(echo "$tmux_config") new-session && echo "$(tmux -V) created new session supported OS X"
            else
                tmux new-session && echo "tmux created new session"
            fi
        fi
    fi
}
tmux_automatically_attach_session

