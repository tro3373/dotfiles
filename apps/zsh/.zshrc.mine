## Environment variable configuration
#
# LANG
#
export LANG=ja_JP.UTF-8
case ${UID} in
0)
    LANG=C
    ;;
esac


## Default shell configuration
#
# set prompt
# 使用できる色は以下で確認できる
# ('\e[38;5;詳細前景色コードm'と'\e[m'で文字を囲むと文字が256色の設定ができる
# 文字色を変える場合は最初の数字を 38、背景の場合は 48を利用する)
#
#   for c in {000..255}; do echo -n "\e[38;5;${c}m $c" ; [ $(($c%16)) -eq 15 ] && echo;done;echo
#  または
#   for c in {016..255}; do echo -n "\e[38;5;${c}m $c" ; [ $(($((c-16))%6)) -eq 5 ] && echo;done;echo
#
autoload colors
colors
case ${UID} in
0)
    PROMPT="%{${fg[red]}%}$(echo ${HOST%%.*} | tr '[a-z]' '[A-Z]') %B%{${fg[red]}%}%/#%{${reset_color}%}%b "
    PROMPT2="%B%{${fg[red]}%}%_#%{${reset_color}%}%b "
    SPROMPT="%B%{${fg[red]}%}%r is correct? [n,y,a,e]:%{${reset_color}%}%b "
    ;;
*)
    #PROMPT="%{${fg[cyan]}%}%/$%{${reset_color}%} "
    #PROMPT2="%{${fg[red]}%}%_%%%{${reset_color}%} "
    #SPROMPT="%{${fg[red]}%}%r is correct? [n,y,a,e]:%{${reset_color}%} "
    # ???
    #PROMPT=$'%{\e[38;5;030m%}%m%(!.#.$)%{\e[m%} '
    # cyan
    #PROMPT=$'%{\e[38;5;030m%}%/$%{\e[m%} '
    PROMPT=$'%{\e[38;5;033m%}%/$%{\e[m%} '
    PROMPT2=$'%{\e[38;5;033m%}%_> %{\e[m%} '
    SPROMPT="%{${fg[red]}%}%r is correct? [n,y,a,e]:%{${reset_color}%} "
    [ -n "${REMOTEHOST}${SSH_CONNECTION}" ] &&
        PROMPT="%{${fg[magenta]}%}$(echo ${HOST%%.*} | tr '[a-z]' '[A-Z]') ${PROMPT}"
    ;;
esac

# 'cd'を打たなくてもディレクトリ名だけで移動できるようにする
#
setopt auto_cd

# ディレクトリ移動時に自動でpushdされる 'cd -<TAB>' で履歴が表示される
# 'cd -3'とかするとその番号のディレクトリに移動する
#
setopt auto_pushd

# コマンドの打ち間違い(typo)を訂正してくれるようにする
#
setopt correct

# TAB補完時の候補を詰めて表示(一度にたくさん表示)
#
setopt list_packed

# パス名の最後につく'/'を自動的に削除しない
#
setopt noautoremoveslash

# 補完機能実行時にビープ音を鳴らさない
#
setopt nolistbeep


## キーバインドの設定
#
# <ESC>を押した時にvi風のキー操作ができるようにする
#
bindkey -v

# コマンド履歴の検索時に <Ctrl-p>で履歴をさかのぼり、<Ctrl-n>で履歴を下る
#
autoload history-search-end
zle -N history-beginning-search-backward-end history-search-end
zle -N history-beginning-search-forward-end history-search-end
bindkey "^p" history-beginning-search-backward-end
bindkey "^n" history-beginning-search-forward-end
bindkey "\\ep" history-beginning-search-backward-end
bindkey "\\en" history-beginning-search-forward-end

# <TAB>での補完候補の変更時に、<Shift-TAB>で逆順に変更する
#
bindkey "\e[Z" reverse-menu-complete


## コマンド履歴の設定
#
HISTFILE=${HOME}/.zsh_history
HISTSIZE=50000
SAVEHIST=50000
setopt hist_ignore_dups     # 重複したコマンドは履歴保存しない
setopt share_history        # コマンド履歴ファイルを複数のzshプロセス間で共有


## 補完機能の設定
#
fpath=(${HOME}/.zsh/functions/Completion ${fpath})
autoload -U compinit        # 補完機能を有効にする
compinit


## zsh editorを有効にする
#
autoload zed


## 先方予測によるコマンド補完機能の設定
#  (使いこなせないので無効しとく)
#
#autoload predict-on
#predict-off


## コマンドエイリアスの設定
#
setopt complete_aliases     # エイリアスを展開してもとのコマンドをみつけて, そのコマンドに応じた補完


## ターミナルの設定
#
case "${TERM}" in
screen)
    TERM=xterm
    ;;
esac

case "${TERM}" in
xterm|xterm-color)
    export LSCOLORS=exfxcxdxbxegedabagacad
    export LS_COLORS='di=34:ln=35:so=32:pi=33:ex=31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;30:ow=43;30'
    # zstyle ':completion:*' list-colors 'di=34' 'ln=35' 'so=32' 'ex=31' 'bd=46;34' 'cd=43;34'
    # zshの補完にも同じ色を設定
    zstyle ':completion:*' list-colors ${(s.:.)LS_COLORS}
    ;;
kterm-color)
    stty erase '^H'
    export LSCOLORS=exfxcxdxbxegedabagacad
    export LS_COLORS='di=34:ln=35:so=32:pi=33:ex=31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;30:ow=43;30'
    zstyle ':completion:*' list-colors 'di=34' 'ln=35' 'so=32' 'ex=31' 'bd=46;34' 'cd=43;34'
    ;;
kterm)
    stty erase '^H'
    ;;
cons25)
    unset LANG
    export LSCOLORS=ExFxCxdxBxegedabagacad
    export LS_COLORS='di=01;34:ln=01;35:so=01;32:ex=01;31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;30:ow=43;30'
    zstyle ':completion:*' list-colors 'di=;34;1' 'ln=;35;1' 'so=;32;1' 'ex=31;1' 'bd=46;34' 'cd=43;34'
    ;;
jfbterm-color)
    export LSCOLORS=gxFxCxdxBxegedabagacad
    export LS_COLORS='di=01;36:ln=01;35:so=01;32:ex=01;31:bd=46;34:cd=43;34:su=41;30:sg=46;30:tw=42;30:ow=43;30'
    zstyle ':completion:*' list-colors 'di=;36;1' 'ln=;35;1' 'so=;32;1' 'ex=31;1' 'bd=46;34' 'cd=43;34'
    ;;
esac

# dircolors 設定
#
if [ -e ~/.dircolors ]; then
    if type dircolors > /dev/null 2>&1; then
        eval $(dircolors ~/.dircolors)
    elif type gdircolors > /dev/null 2>&1; then
        eval $(gdircolors ~/.dircolors)
    fi
fi

# ターミナルの時はタイトル部分にカレントディレクトリを表示する
#
case "${TERM}" in
xterm|xterm-color|kterm|kterm-color)
    precmd() {
        echo -ne "\033]0;${USER}@${HOST%%.*}:${PWD}\007"
    }
    ;;
esac


## PATHの設定
#
function is_exist_path() {
    echo "$PATH:" |grep "$@:" > /dev/null 2>&1
    return $?
}
# パス追加(追加パスは前から重複を無くして追加)
#
function add_path() {
    targetPath="$@"
    #echo "==============> Add start!!!!!"
    #echo "targetPath="$targetPath
    if [ ! -f ${targetPath} ] &&
        [ ! -d ${targetPath} ] &&
        [ ! -L ${targetPath} ]; then
        # 存在しないパスの場合無視する.
        #echo "$targetPath is not exist. return."
        return
    fi
    # 既にパスに追加されている場合は削除する.
    if is_exist_path $targetPath; then
        #echo "$targetPath is already pathed. remove it."
        # $targetPath を $PATH から削除.
        #PATH=${PATH#"$targetPath:"}
        PATH=`echo $PATH |sed -e "s|$targetPath||g" |sed -e 's/::/:/g'`
    fi
    #echo "$targetPath is will be pathed."
    export PATH=$targetPath:$PATH
}

# ~/bin
add_path ${HOME}/bin
# .local/bin
add_path ${HOME}/.local/bin

# --------------------------------------------------------
# anyenv
# --------------------------------------------------------
if [ -d ${HOME}/.anyenv ] ; then
    add_path ${HOME}/.anyenv/bin
#    export PATH="$HOME/.anyenv/bin:$PATH"
    eval "$(anyenv init -)"
#     for D in `ls $HOME/.anyenv/envs`
#     do
#         export PATH="$HOME/.anyenv/envs/$D/shims:$PATH"
#     done
fi

## --------------------------------------------------------
## rbenv
## --------------------------------------------------------
#if [ -e ~/.rbenv ]; then
#    export PATH="$HOME/.rbenv/bin:$PATH"
#    eval "$(rbenv init -)"
#fi
## --------------------------------------------------------
## nvm
## --------------------------------------------------------
#if [ -e ~/.nvm ]; then
#    . ~/.nvm/nvm.sh
#    nvm use v0.10.38
#fi
## --------------------------------------------------------
## Python
## --------------------------------------------------------
#if [ "`which virtualenvwrapper.sh >/dev/null 2>&1; echo $?`" = "0" ]; then
#    export WORKON_HOME=$HOME/.virtualenvs
#    export PROJECT_HOME=$HOME/Devel
#    source virtualenvwrapper.sh
#fi

# --------------------------------------------------------
# Java
# --------------------------------------------------------
#javahome=~/bin/java/jdk1.6.0_45
#javahome=~/bin/java/jdk1.8.0_05
javahome=~/bin/java/jdk1.8.0_20
if [ -e $javahome ]; then
    export JAVA_HOME=`echo "$javahome"`
    add_path ${JAVA_HOME}/bin
fi

# --------------------------------------------------------
# Maven
# --------------------------------------------------------
# see http://blog.beaglesoft.net/?p=762
# wget http://ftp.riken.jp/net/apache/maven/maven-3/3.3.3/binaries/apache-maven-3.3.3-bin.tar.gz
# tar xvfpz apache-maven-3.3.3-bin.tar.gz
mvnhome=~/bin/apache-maven-3.3.3
if [ -e $mvnhome ]; then
    export M2_HOME=$mvnhome
    add_path ${M2_HOME}/bin
fi

# For docker-machine etc.
add_path /opt/bin
# For docker-machine settings.
#if `which docker-machine > /dev/null 2>&1` &&
#    [ -e $HOME/.docker/machine/machines/dev ]; then
#    echo "# For start docker-machine name \"dev\" and docker env setting."
#    echo "#  docker-mahine start dev"
#    echo "#  docker-mahine env dev"
#    echo "#  eval \"\$(docker-mahine env dev)\""
#fi

# Added by the Heroku Toolbelt
add_path /usr/local/heroku/bin

# Android Studioでresponsがなくなる？
# Ubuntu の設定
# http://tools.android.com/knownissues/ibus
#IBUS_ENABLE_SYNC_MODE=1 ibus-daemon -xrd

# Android platform-tools for Mac.
add_path ~/Library/Android/sdk/platform-tools


# zsh powerline 設定
#zshpowerline=${HOME}/.local/lib/python2.7/site-packages/powerline/bindings/zsh/powerline.zsh
#[ -f ${zshpowerline} ] && source ${zshpowerline}

# zshが終了するときに自動的にssh-agentを終了させる
#TRAPEXIT() {
#    ssh-agent -k
#}

